#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"
#+TODO: TODO IDEA | DONE

* Ideas
Ideas for improving this config are collected here.

** IDEA Workspace-aware browser launcher
Credit: [[https://github.com/altercation/dotfiles-tilingwm/blob/31e23a75eebdedbc4336e7826800586617d7d27d/.xmonad/xmonad.hs#L406][Ethan Schoonover]]
I could configure the browser launcher to select particular profiles or tabs to start with - based on the workspace.
Since most of my workspaces are generic, using workspace names to decide might be a good idea.
This could be a significant gain.

#+begin_example
workspace name = "grading" --> tabs: <gradescope> <gmail/.jobs>
workspace name = "config" --> tabs: <xmonad> ...
#+end_example

** TODO Add support for Polybar
** TODO Translate some keys to Firefox shortcuts when it is open
I've used this in a previous setup, and it works amazingly well.
** TODO Use =Text= instead of =String=, and possibly a different Prelude like =Relude=
Apparently =String= /really/ sucks. TIL a character takes *40 Bytes*, and that's just way too much.
I'm finally convinced it's worth switching.

* Imports
Libraries for system IO actions
#+begin_src haskell
import System.Process (system, readProcess)
import System.Posix.Process (executeFile)
import System.Posix.Signals (signalProcess, sigKILL)
import Control.Concurrent (threadDelay)
import System.Environment (getArgs)
import System.Exit (exitSuccess, ExitCode(..))
import Control.Exception
#+end_src

Some general libraries
#+begin_src haskell
import Control.Monad
import qualified Data.Map as M
import Data.List
import Data.Bifunctor
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad hiding (Color)
#+end_src

Some utilities from =xmonad-contrib=
#+begin_src haskell
import XMonad.Util.Run
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Font (Align(..))
import XMonad.Actions.Submap (submap)
#+end_src

Change the cursor
#+begin_src haskell
import XMonad.Util.Cursor (setDefaultCursor, xC_left_ptr)
#+end_src

Easy formatting
#+begin_src haskell
import Text.Printf
#+end_src

* Markup(s)
** Dzen
Define interfaces for markup languages used later.

First, dzen for the =which-key= popups.
dzen has a lot more formatting options, like rectangles, xbm icons, and whatnot.
Might be interesting to explore later.
#+begin_src haskell
type Color = String

dzenFg, dzenBg :: Color -> String -> String
dzenFg color string = printf "^fg(%s)%s^fg()" color string
dzenBg color string = printf "^bg(%s)%s^bg()" color string
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

We use =dzen= with some basic settings to display text on the screen. I would've liked to use =XMonad.Util.Dzen= for this,
but it only contains =X= actions, while we only have access to =IO= in some situations.
#+begin_src haskell
displayTextFont = "Iosevka:pixelsize=15"

displayText :: MonadIO m => String -> m ()
displayText text = io . void $ readProcess "dzen2"
  [ "-p"
  , "-l", show numLines
  , "-ta", "c" , "-sa", "c"
  , "-e", "onstart=uncollapse"                  -- show all lines at startup (by default they only show on mouse hover)
  , "-fn", displayTextFont
  ]
  text
  where
    numLines = max 0 (length (lines text) - 1)  -- we only count slave lines, so everything after the first one
#+end_src

We then need a pretty-printer for displaying the keybindings. The =NamedActions= module has functions for naming and printing keybindings, but unfortunately it's too restrictive and doesn't allow any customization. I realized that
I don't require much of that functionality, and the provided pretty-printer is kind of ugly.
Let's define our own the pretty-printer first.
I'm using =equalizeLeft= and =equalizeRight= since we're using center-aligning in =dzen=, so the lines need to be of equal length to match up.
#+begin_src haskell
data WhichkeyConfig
  = WhichkeyConfig
  { keyFg  :: Color     -- ^ foreground color for keys
  , descFg :: Color     -- ^ foreground color for action descriptions
  , delay  :: Rational  -- ^ delay (in seconds) after which whichkey pops up
  }

instance Default WhichkeyConfig where
  def = WhichkeyConfig
    { keyFg  = "orange"
    , descFg = "light blue"
    , delay  = 3
    }

whichkeyShowBindings :: WhichkeyConfig -> [(String, String, X ())] -> [String]
whichkeyShowBindings whichkeyConf keybinds =
  fmap (\(key, desc) -> printf "%s -> %s"
   (dzenFg (keyFg whichkeyConf) key) (dzenFg (descFg whichkeyConf) desc)) $
  uncurry zip $ bimap equalizeLeft equalizeRight $ unzip $ dropThd <$> keybinds
  where
    dropThd (a,b,c) = (a,b)

    equalizeLeft strings =
      let maxLen = maximum (length <$> strings) in
      fmap (\string -> replicate (maxLen - length string) ' ' ++ string) strings

    equalizeRight strings =
      let maxLen = maximum (length <$> strings) in do
      fmap (\string -> string ++ replicate (maxLen - length string) ' ') strings
#+end_src

Like emacs' =which-key=, the help message should activate after a delay and close by itself if any key is pressed.
Let's define a custom submap function for that. For the reasons stated above, I'm using simple strings instead of the =NamedActions= module here.
See [[opening-apps]] for a usage example.
*NOTE*: this might cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue, since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: (LayoutClass l Window, Read (l Window))
               => WhichkeyConfig
               -> XConfig l
               -> [(String, String, X ())]
               -> X ()
whichkeySubmap whichkeyConf config keybinds = do
  pid <- xfork (threadDelay (seconds $ delay whichkeyConf) >> displayText (toHelp keybinds))
  catchX (submap . mkKeymap config $ dropSnd <$> keybinds) mempty
  io $ signalProcess sigKILL pid
  spawn "pkill dzen2"
  where
    toHelp = unlines . whichkeyShowBindings whichkeyConf
    dropSnd (a,b,c) = (a,c)
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , handleExtraArgs = handleTestConditions
  , keys            = myKeymap
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

handleTestConditions :: [String] -> XConfig Layout -> IO (XConfig Layout)
handleTestConditions args config = case args of
  []         -> return config
  ["--test"] -> return config { modMask = testModMask }
  otherwise  -> putStrLn ("Unexpected arguments encountered: " ++ show args) >> return config
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  , infoKeys
  ]
#+end_src

Some quick helper functions
#+begin_src haskell
spawnKeymap :: String -> [(String, String, String)] -> (String, X ())
spawnKeymap key items = (key, whichkeySubmap def myConfig $ mapThd spawn <$> items)
  where mapThd f (a,b,c) = (a,b,f c)
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~, but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = return $ spawnKeymap "M-u" apps
  where
    apps = [ ("t"  , "Terminal"    , terminal myConfig)
           , ("e"  , "Emacs Client", "emacsclient -c")
           , ("S-e", "Emacs"       , "emacs")
           , ("f"  , "Firefox"     , "firefox")
           , ("r"  , "Ranger"      , "$TERMINAL ranger")
           , ("w"  , "WhatsApp"    , "whatsapp.sh")
           ]
#+end_src

*** Info keys
Keys for referring to information quickly - latex symbols, nerdfont icons etc.
#+begin_src haskell
infoKeys = return $ spawnKeymap "M-i" info
  where
    info = [ ("n"  , "Nerdfont reference"      , "nerdfont-dmenu.sh")
           , ("l"  , "LaTeX symbol reference"  , "xdg-open http://detexify.kirelabs.org/classify.html")
           , ("x m", "xmonad reference"        , "xdg-open https://hackage.haskell.org/package/xmonad")
           , ("x c", "xmonad-contrib reference", "xdg-open https://hackage.haskell.org/package/xmonad-contrib")
           ]
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
The default cursor is also... not the best - change it to something more standard.
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
    setDefaultCursor xC_left_ptr
#+end_src

* Running
** Restarting
=restartConfig= copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
Using =SomeException= catches all exceptions
#+begin_src haskell
buildConfig :: X Bool
buildConfig =
  io $ (try (system "bin/build") :: IO (Either SomeException ExitCode)) >>= \case
    Right ExitSuccess -> return True
    Right (ExitFailure failCode) -> displayText (printf "Build failed with code %d" failCode) >> return False
    Left exception -> displayText (displayException exception) >> return False


restartConfig :: Bool -> X ()
restartConfig resume = do
  uninstallSignalHandlers
  whenX buildConfig $ do
    broadcastMessage ReleaseResources
    io . flush =<< asks display
    when resume writeStateToFile
    origArgs <- io getArgs
    catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Main
The default =xmonad= executable handles a lot of things in its =main= -- replacing, resuming, building etc.
This makes it a lot more complicated to think about as we might reenter =main= at any point while maintaining state in the filesystem.
To keep things simple, in this configuration, building is handled by the =build= script which can be executed by hand or during recompilation through the executable.
#+begin_src haskell
main :: IO ()
main = do
  args <- getArgs
  conf' @ XConfig { layoutHook = Layout l }
                  <- handleExtraArgs myConfig args myConfig{ layoutHook = Layout (layoutHook myConfig) }
  launch $ conf' { layoutHook = l }
#+end_src
