#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"
#+TODO: TODO IDEA | DONE

* Ideas & Fixes
** IDEA Workspace-aware browser launcher
Credit: [[https://github.com/altercation/dotfiles-tilingwm/blob/31e23a75eebdedbc4336e7826800586617d7d27d/.xmonad/xmonad.hs#L406][Ethan Schoonover]]
I could configure the browser launcher to select particular profiles or tabs to start with - based on the workspace.
Since most of my workspaces are generic, using workspace names to decide might be a good idea.
This could be a significant gain.

#+begin_example
workspace name = "grading" --> tabs: <gradescope> <gmail/.jobs>
workspace name = "config" --> tabs: <xmonad> ...
#+end_example

** TODO Translate some keys to Firefox shortcuts when it is open
I've used this in a previous setup, and it works amazingly well.
** TODO Use =Text= instead of =String=, and possibly a different Prelude like =Relude=
Apparently =String= /really/ sucks. TIL a character takes *40 Bytes*, and that's just way too much.
I'm finally convinced it's worth switching.
** IDEA Convert this to a literate haskell file while maintaining org syntax
Pros:
- Provides editor support for haskell --> this is a /huge/ benefit
- Can split up files, if required
- No tangling required

Cons:
- Possibly removes editor support for org-mode
- Doesn't allow source blocks for other languages
- Have to add both org and literate-haskell markup for code blocks
** IDEA Use =X.L.Stoppable= to develop a power-savings mode
Maybe auto-enable it when battery is below a threshold.
** TODO =displayText= blocks forever. Make it fork and add an optional timer.
** TODO Silence build notifications when testing.

* Imports
Libraries for system IO actions
#+begin_src haskell
import System.IO
import System.Posix.IO
import System.Posix.Types (CPid(..))
import System.Process (system, readProcess)
import System.Posix.Process (executeFile, getProcessID)
import System.Posix.Signals (signalProcess, sigKILL)
import Control.Concurrent (threadDelay)
import System.Environment (getArgs)
import System.Exit (exitSuccess, ExitCode(..))
import Control.Exception (try, displayException, SomeException)
#+end_src

Some general libraries
#+begin_src haskell
import Control.Monad
import qualified Data.Map as M
import Data.List
import Data.Bifunctor (bimap)
import Data.Maybe
import Data.Char
import Data.Tuple.Extra
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad hiding (Color)
#+end_src

Some utilities from =xmonad-contrib=
#+begin_src haskell
import XMonad.Util.Run
import XMonad.Layout.LayoutModifier (ModifiedLayout)
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Font (Align(..))
import XMonad.Actions.Submap (submap)
#+end_src

Change the cursor
#+begin_src haskell
import XMonad.Util.Cursor (setDefaultCursor, xC_left_ptr)
#+end_src

Easy formatting
#+begin_src haskell
import Text.Printf
#+end_src

Some helpers for output and parsing
#+begin_src haskell
import XMonad.Config.Dmwit (outputOf, splitColon)
import Text.Read
#+end_src

Libraries for managing and logging to the status bar.
#+begin_src haskell
import XMonad.Hooks.DynamicLog
import XMonad.Hooks.DynamicBars
import XMonad.Hooks.ManageDocks (docks, avoidStruts, AvoidStruts)
#+end_src

Libraries for pretty-printing to the status bar
#+begin_src haskell
import XMonad.Util.WorkspaceCompare (getSortByIndex)
#+end_src

* Markup(s)
Define interfaces for markup languages used later.

** Dzen
First, dzen for the =which-key= popups.
dzen has a lot more formatting options, like rectangles, xbm icons, and whatnot.
Might be interesting to explore later.
#+begin_src haskell
type Color = String

dzenFg, dzenBg :: Color -> String -> String
dzenFg color string = printf "^fg(%s)%s^fg()" color string
dzenBg color string = printf "^bg(%s)%s^bg()" color string
#+end_src

** Lemonbar
Enumerate the mouse buttons. We'll use the =Enum= instance to use it in the markup, but
since the default =Enum= instance starts counting from 0 and we want to start from 1, we'll have to add 1 to it.
#+begin_src haskell
data MouseButton
  = LeftClick
  | MiddleClick
  | RightClick
  | ScrollUp
  | ScrollDown
  | DoubleLeftClick
  | DoubleMiddleClick
  | DoubleRightClick
  deriving (Eq, Ord, Show, Enum)

fromMouseButton :: MouseButton -> Int
fromMouseButton = succ . fromEnum
#+end_src

Then we define the formatting possibilities in lemonbar markup.
#+begin_src haskell
data LemonbarFormatting
  = Foreground String
  | Background String
  | Reverse
  | Underline String
  | Overline String
  | Font Int
  | Offset Int
  | Action MouseButton String
  deriving (Eq, Show)
#+end_src

And finally convert these to markup using the [[https://github.com/LemonBoy/bar#formatting][lemonbar formatting spec]].
#+begin_src haskell
bracket :: String -> String
bracket = wrap "%{" "}"

lemonbarFormatOne :: LemonbarFormatting -> String -> String
lemonbarFormatOne (Foreground color) = wrap (bracket $ "F" <> color) (bracket "F-")
lemonbarFormatOne (Background color) = wrap (bracket $ "B" <> color) (bracket "B-")
lemonbarFormatOne Reverse            = wrap (bracket "R") (bracket "R")
lemonbarFormatOne (Underline color)  = wrap (bracket ("u" <> color) <> bracket "+u") (bracket "-u")
lemonbarFormatOne (Overline color)   = wrap (bracket ("o" <> color) <> bracket "+o") (bracket "-o")
lemonbarFormatOne (Font index)       = wrap (bracket "T" <> show index) (bracket "T-")
lemonbarFormatOne (Offset size)      = (bracket ("O" <> show size) <>)
lemonbarFormatOne (Action button command) =
  wrap (bracket (printf "A%d:%s:" (fromMouseButton button) command)) (bracket "A")

lemonbarFormat :: [LemonbarFormatting] -> String -> String
lemonbarFormat fmts = foldr (.) id (lemonbarFormatOne <$> fmts)
#+end_src

* Colors
** one-dark
#+begin_src haskell
onedarkBlack  = "#282c34"
onedarkRed    = "#e06c75"
onedarkGreen  = "#98c379"
onedarkYellow = "#e5c07b"
onedarkBlue   = "#61afef"
onedarkPurple = "#c678dd"
onedarkCyan   = "#56b6c2"
onedarkGrey   = "#abb2bf"

onedarkGreenDarker = "#68a349"
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

We use =dzen= with some basic settings to display text on the screen. I would've liked to use =XMonad.Util.Dzen= for this,
but it only contains =X= actions, while we only have access to =IO= in some situations.
#+begin_src haskell
displayTextFont = "Iosevka:pixelsize=15"

displayText :: MonadIO m => String -> m ()
displayText text = io . void $ readProcess "dzen2"
  [ "-p"
  , "-l", show numLines
  , "-ta", "c" , "-sa", "c"
  , "-e", "onstart=uncollapse"                  -- show all lines at startup (by default they only show on mouse hover)
  , "-fn", displayTextFont
  ]
  text
  where
    numLines = max 0 (length (lines text) - 1)  -- we only count slave lines, so everything after the first one
#+end_src

We then need a pretty-printer for displaying the keybindings. The =NamedActions= module has functions for naming and printing keybindings, but unfortunately it's too restrictive and doesn't allow any customization. I realized that
I don't require much of that functionality, and the provided pretty-printer is kind of ugly.
Let's define our own the pretty-printer first.
I'm using =equalizeLeft= and =equalizeRight= since we're using center-aligning in =dzen=, so the lines need to be of equal length to match up.
#+begin_src haskell
data WhichkeyConfig
  = WhichkeyConfig
  { keyFg  :: Color     -- ^ foreground color for keys
  , descFg :: Color     -- ^ foreground color for action descriptions
  , delay  :: Rational  -- ^ delay (in seconds) after which whichkey pops up
  }

instance Default WhichkeyConfig where
  def = WhichkeyConfig
    { keyFg  = "orange"
    , descFg = "light blue"
    , delay  = 3
    }

whichkeyShowBindings :: WhichkeyConfig -> [(String, String, X ())] -> [String]
whichkeyShowBindings whichkeyConf keybinds =
  fmap (\(key, desc) -> printf "%s -> %s"
   (dzenFg (keyFg whichkeyConf) key) (dzenFg (descFg whichkeyConf) desc)) $
  uncurry zip $
  bimap equalizeLeft equalizeRight $
  unzip $
  first capitalizeIfShift . dropThd <$> keybinds
  where
    dropThd (a,b,c) = (a,b)

    capitalizeIfShift keystr = case reverse keystr of
      (c : '-' : 'S' : rest) -> if isAlpha c then
                                  reverse (rest ++ [toUpper c])
                                else
                                  keystr
      _ -> keystr

    equalizeLeft strings =
      let maxLen = maximum (length <$> strings) in
      fmap (\string -> replicate (maxLen - length string) ' ' ++ string) strings

    equalizeRight strings =
      let maxLen = maximum (length <$> strings) in do
      fmap (\string -> string ++ replicate (maxLen - length string) ' ') strings
#+end_src

Like emacs' =which-key=, the help message should activate after a delay and close by itself if any key is pressed.
Let's define a custom submap function for that. For the reasons stated above, I'm using simple strings instead of the =NamedActions= module here.
See [[opening-apps]] for a usage example.
*NOTE*: this might cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue, since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: (LayoutClass l Window, Read (l Window))
               => WhichkeyConfig
               -> XConfig l
               -> [(String, String, X ())]
               -> X ()
whichkeySubmap whichkeyConf config keybinds = do
  pid <- xfork (threadDelay (seconds $ delay whichkeyConf) >> displayText (toHelp keybinds))
  catchX (submap . mkKeymap config $ dropSnd <$> keybinds) mempty
  io $ signalProcess sigKILL pid
  spawn "pkill dzen2"
  where
    toHelp = unlines . whichkeyShowBindings whichkeyConf
    dropSnd (a,b,c) = (a,c)
#+end_src

* Polybar
[[https://github.com/polybar/polybar][Polybar]] is pretty cool. It has a lot of efficient modules for most things and is quite customizable.
Aside from the actual choice of bar, there are things I want from a status bar:
1. Show workspaces, Layout, extras etc. with nice highlighting
2. Workspace indicators on the bar should focus that workspace on being clicked
3. Different highlighting for bars on unfocused monitors
4. On adding or removing a monitor, bars should be added or deleted automatically

The first of these requirements is pretty standard, and can be achieved using some =lemonbar= markup that Polybar uses.
The second can be achieved with =xdotool set_desktop <workspace>=. This requires EWMH compliance which can be achieved with =X.H.EwmhDesktops=.
The third and fourth can be achieved with =X.H.DynamicBars=.

** Pretty-printing
The basic pretty-printer which the upcoming ones should override.
#+begin_src haskell
basicPP :: PP
basicPP = def
  { ppSep = "  "
  , ppWsSep = " "
  , ppTitleSanitize = filter (`notElem` "%{}")
  , ppOrder = layoutFirstOrder
  , ppSort = getSortByIndex
  , ppExtras = []
  , ppOutput = const mempty
  }
  where
    layoutFirstOrder (workspaces : layout : title : extras) =
      [layout] ++ extras ++ [workspaces, title]
    layoutFirstOrder other = other
#+end_src

And the chosen one is:
#+begin_src haskell
chosenPP = (onedarkFocusedPP, onedarkUnfocusedPP)
#+end_src

*** one-dark
#+begin_src haskell
onedarkFocusedPP = basicPP
  { ppCurrent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkGreen, Underline onedarkGreenDarker ] . pad
  , ppVisible = lemonbarFormat [ Foreground onedarkGreen, Background onedarkGrey, Underline onedarkGreen ] . pad
  , ppVisibleNoWindows = Just $ lemonbarFormat [ Foreground onedarkBlack, Background onedarkGrey, Underline onedarkGreen ] . pad
  , ppHidden = lemonbarFormat [ Foreground onedarkGreen, Underline onedarkGreen ] . pad
  , ppHiddenNoWindows = lemonbarFormat [ Foreground onedarkGrey ] . pad
  , ppUrgent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkRed ] . pad
  , ppTitle = lemonbarFormat [ Foreground onedarkGrey ] . shorten 50
  , ppLayout = lemonbarFormat [ Foreground onedarkYellow ]
  }

onedarkUnfocusedPP = onedarkFocusedPP
  { ppCurrent = fromJust $ ppVisibleNoWindows onedarkFocusedPP
  , ppVisible = ppHiddenNoWindows onedarkFocusedPP
  , ppVisibleNoWindows = Just $ ppHiddenNoWindows onedarkFocusedPP
  , ppHidden = ppHiddenNoWindows onedarkFocusedPP
  }
#+end_src

** Dynamic bar highlighting and management
=DynamicBars= asks for a bar startup function of the type =ScreenId -> IO Handle=, where =ScreenId= is simply a newtype for =Int=.
On the other hand, Polybar requires an xrandr monitor name to know which screen to use. So first we need a mapping between the two.
I simply use =xrandr= to query which monitors are active and hope to dear god that they are in the same order as the =ScreenId='s.
So far I have not been let down.
#+begin_src haskell
monitorIds :: IO [(ScreenId, String)]
monitorIds = do
  output <- outputOf "xrandr --listactivemonitors 2>/dev/null | awk '{print $1 $4}'"
  return $ mapMaybe parseMonitor $ drop 1 $ lines output
  where
    parseMonitor :: String -> Maybe (ScreenId, String)
    parseMonitor string = case splitColon string of
      [a,b] ->
        case readMaybe a of
          Just a' -> Just (S a', b)
          Nothing -> Nothing

      _ -> Nothing
#+end_src

We want to use =spawnPipe= to start polybar and pass input to its stdin, but unfortunately polybar doesn't read from there.
So we need to use an intermediary to pass it into polybar through a named pipe. We /could/ do this from xmonad itself, but then
we have to maintain consistency between xmonad and polybar about the name of the pipe. That, and using named pipes in haskell
turns out to have a lot of gotchas. We do this through a shell script =polybar-start-monitor.sh=

The relevant polybar module just reads a the passed environment variable =STDINFIFO=
#+begin_src conf :tangle no
[module/stdin]
type = custom/script
tail = true
exec = cat $STDINFIFO
#+end_src

And finally the startup and cleanup functions for the bar.
#+begin_src haskell
polybarStartup :: ScreenId -> IO Handle
polybarStartup screenId = do
  monitors <- monitorIds
  case lookup screenId monitors of
    Just monitor -> spawnPipe $ "bin/polybar-start-monitor.sh " <> monitor
    Nothing -> error $ printf "No monitor found for %s in %s" (show screenId) (show monitors)

polybarCleanup :: IO ()
polybarCleanup = do
  (CPid pid) <- getProcessID
  spawn $ printf "pkill --parent %d bin/polybar-start-monitor.sh" pid
#+end_src

And then plumb everything together with =DynamicBars= and =ManageDocks= (to actually make space for the bar).
#+begin_src haskell
polybarEnable :: LayoutClass l Window
              => PP
              -> PP
              -> XConfig l
              -> XConfig (ModifiedLayout AvoidStruts l)
polybarEnable focusedPP unfocusedPP config  = docks $ config
  { startupHook     = startupHook config     <+> dynStatusBarStartup polybarStartup polybarCleanup
  , handleEventHook = handleEventHook config <+> dynStatusBarEventHook polybarStartup polybarCleanup
  , logHook         = logHook config         <+> multiPP focusedPP unfocusedPP
  , layoutHook      = avoidStruts $ layoutHook config
  }
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , handleExtraArgs = handleTestConditions
  , keys            = myKeymap
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

handleTestConditions :: [String] -> XConfig Layout -> IO (XConfig Layout)
handleTestConditions args config = case args of
  []         -> return config
  ["--test"] -> return config { modMask = testModMask }
  otherwise  -> putStrLn ("Unexpected arguments encountered: " ++ show args) >> return config
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  , infoKeys
  ]
#+end_src

Some quick helper functions
#+begin_src haskell
spawnKeymap :: String -> [(String, String, String)] -> (String, X ())
spawnKeymap key items = (key, whichkeySubmap def myConfig $ mapThd spawn <$> items)
  where mapThd f (a,b,c) = (a,b,f c)
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~, but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = return $ spawnKeymap "M-u" apps
  where
    apps = [ ("t"  , "Terminal"    , terminal myConfig)
           , ("e"  , "Emacs Client", "emacsclient -c")
           , ("S-e", "Emacs"       , "emacs")
           , ("f"  , "Firefox"     , "firefox")
           , ("r"  , "Ranger"      , "$TERMINAL ranger")
           , ("w"  , "WhatsApp"    , "whatsapp.sh")
           ]
#+end_src

*** Info keys
Keys for referring to information quickly - latex symbols, nerdfont icons etc.
#+begin_src haskell
infoKeys = return $ spawnKeymap "M-i" info
  where
    info = [ ("n"  , "Nerdfont reference"      , "nerdfont-dmenu.sh")
           , ("l"  , "LaTeX symbol reference"  , "xdg-open http://detexify.kirelabs.org/classify.html")
           , ("x m", "xmonad reference"        , "xdg-open https://hackage.haskell.org/package/xmonad")
           , ("x c", "xmonad-contrib reference", "xdg-open https://hackage.haskell.org/package/xmonad-contrib")
           ]
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
The default cursor is also... not the best - change it to something more standard.
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
    setDefaultCursor xC_left_ptr
#+end_src

* Running
** Restarting
=restartConfig= copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
Using =SomeException= catches all exceptions
#+begin_src haskell
buildConfig :: X Bool
buildConfig =
  io $ (try (system "bin/build") :: IO (Either SomeException ExitCode)) >>= \case
    Right ExitSuccess -> return True
    Right (ExitFailure failCode) -> displayText (printf "Build failed with code %d" failCode) >> return False
    Left exception -> displayText (displayException exception) >> return False


restartConfig :: Bool -> X ()
restartConfig resume = do
  uninstallSignalHandlers
  whenX buildConfig $ do
    broadcastMessage ReleaseResources
    io . flush =<< asks display
    when resume writeStateToFile
    origArgs <- io getArgs
    catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Main
The default =xmonad= executable handles a lot of things in its =main= -- replacing, resuming, building etc.
This makes it a lot more complicated to think about as we might reenter =main= at any point while maintaining state in the filesystem.
To keep things simple, in this configuration, building is handled by the =build= script which can be executed by hand or during recompilation through the executable.
#+begin_src haskell
main :: IO ()
main = do
  args <- getArgs
  conf' @ XConfig { layoutHook = Layout l }
                  <- handleExtraArgs myConfig args myConfig{ layoutHook = Layout (layoutHook myConfig) }
  launch
    $ uncurry polybarEnable chosenPP
    $ conf' { layoutHook = l }
#+end_src
