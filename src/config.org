#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"

* Imports
Libraries for system IO actions
#+begin_src haskell
import System.Process (system)
import System.Posix.Process (executeFile)
import System.Environment (getArgs)
import System.Exit (exitSuccess)
#+end_src

Some general libraries
#+begin_src haskell
import Control.Monad
import qualified Data.Map as M
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap, mkNamedKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Dzen
import XMonad.Util.Font (Align(..))
import XMonad.Util.NamedActions
import XMonad.Actions.Submap (submap)
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

We use =dzen= with some basic settings to display text on the screen
#+begin_src haskell
displayText :: String -> X ()
displayText text = dzenConfig (lineCount numLines >=> unCollapse >=> slaveAlign AlignCenter) text
  where
    numLines = max 0 (length (lines text) - 1)          -- we only count slave lines, so everything after the first one
    unCollapse = addArgs [ "-e", "onstart=uncollapse" ] -- we need to uncollapse at start, otherwise slave lines are only visible on mouseover
#+end_src

The original =which-key= activates after a delay whenever a keybind is partially completed. This would probably be quite hard to achieve in XMonad,
although it's something I would eventually want. In the meantime, a useful compromise is to add a key (say, ~?~ aka ~S-/~) as an extra keybind in each submap.
Let's define a custom submap function for that. Unfortunately, the =NamedActions= module doesn't export =getAction :: NamedAction -> X ()=, which means we have to
work around it using the functions it /does/ export. See [[opening-apps]] for a usage example.
=showKm= isn't a great pretty-printer for the help, it would be nice to improve on this later.
*************** TODO use a better pretty-printer than =showKm=. try to make it print ~S-/~ as ~?~
*************** END
*NOTE*: this will cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue, since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: (LayoutClass l Window, Read (l Window)) => XConfig l -> [(String, NamedAction)] -> X ()
whichkeySubmap config keybinds = submap $ keys config' config' { layoutHook = Layout (layoutHook config') }
  where
    whichkeyBind = (shiftMask, xK_slash)
    whichkeyAction = addName "Show this help" . displayText . unlines . showKm
    keymap = mkNamedKeymap config keybinds
    config' = addDescrKeys' (whichkeyBind, whichkeyAction) (pure keymap) config
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , handleExtraArgs = handleTestConditions
  , keys            = myKeymap
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

handleTestConditions :: [String] -> XConfig Layout -> IO (XConfig Layout)
handleTestConditions args config = case args of
  []         -> return config
  ["--test"] -> return config { modMask = testModMask }
  otherwise  -> putStrLn ("Unexpected arguments encountered: " ++ show args) >> return config
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  ]
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~, but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = [ ("M-u", whichkeySubmap myConfig apps) ]
  where
    apps = [ ("f", spawn' "firefox") ]
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
#+end_src

* Running
** Restarting
Copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
#+begin_src haskell
restartConfig :: Bool -> X ()
restartConfig resume = do
  uninstallSignalHandlers
  io $ system "bin/build"
  broadcastMessage ReleaseResources
  io . flush =<< asks display
  when resume writeStateToFile
  origArgs <- io getArgs
  catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Main
The default =xmonad= executable handles a lot of things in its =main= -- replacing, resuming, building etc.
This makes it a lot more complicated to think about as we might reenter =main= at any point while maintaining state in the filesystem.
To keep things simple, in this configuration, building is handled by the =build= script which can be executed by hand or during recompilation through the executable.
#+begin_src haskell
main :: IO ()
main = do
  args <- getArgs
  conf' @ XConfig { layoutHook = Layout l }
                  <- handleExtraArgs myConfig args myConfig{ layoutHook = Layout (layoutHook myConfig) }
  launch $ conf' { layoutHook = l }
#+end_src
