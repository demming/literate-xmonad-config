#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"
#+TODO: TODO IDEA | DONE

* Ideas & Fixes
** IDEA Workspace-aware browser launcher
Credit: [[https://github.com/altercation/dotfiles-tilingwm/blob/31e23a75eebdedbc4336e7826800586617d7d27d/.xmonad/xmonad.hs#L406][Ethan Schoonover]]
I could configure the browser launcher to select particular profiles or tabs to start with - based on the workspace.
Since most of my workspaces are generic, using workspace names to decide might be a good idea.
This could be a significant gain.

#+begin_example
workspace name = "grading" --> tabs: <gradescope> <gmail/.jobs>
workspace name = "config" --> tabs: <xmonad> ...
#+end_example

** TODO Translate some keys to Firefox shortcuts when it is open
I've used this in a previous setup, and it works amazingly well.
** IDEA Convert this to a literate haskell file while maintaining org syntax
Pros:
- Provides editor support for haskell --> this is a /huge/ benefit
- Can split up files, if required
- No tangling required

Cons:
- Possibly removes editor support for org-mode
- Doesn't allow source blocks for other languages
- Have to add both org and literate-haskell markup for code blocks
** IDEA Use =X.L.Stoppable= to develop a power-savings mode
Maybe auto-enable it when battery is below a threshold.
** TODO =displayText='s message doesn't show up in some situations      :hard:
I investigated this for some time and couldn't figure out why this happens.
Granted, I did only test it in Xephyr.

From some experiments,
- both timed and forever versions work fine in whichkey
- neither work when used as part of =serverCommands=
- they work when used as part of a =spawn= call (=echo ... | dzen2 -p ...=)

The last one suggests that the std input is not being passed correctly.
Wrapping dzen in a shell script and calling that shows that this is indeed correct.
Not sure how to fix it though. The fact that they work in whichkey is really surprising.

** TODO Try to speed up message passing between client and server     :hard:
This is the cause of the ~1s taken for window switching from the status bar.
** IDEA Predefined task setups
This extends the ideas of [[Workspace-aware browser launcher]].
A bunch of "tasks" could be predefined which always need some applications open at the start, maybe along with
positions, layout.
#+begin_example
Grading -> Gradescope, gmail, ...
XMonad -> Emacs, hackage, ...
Homework -> Emacs, hw pdf ...
#+end_example

An XPrompt could then prompt for which task to setup from amongst them.

For extra points, it could use the currently open ones to define a new one.
This would require storage in another format, which is not a big deal.
What is a big deal is figuring out how to start them - i.e. the program name from the window.
Browser tabs also complicate things - not sure if there is a way to query which ones are open in a specific window.
** Ethan Schoonover's XMonad demo
[[https://youtu.be/70IxjLEmomg][youtube link]]
There's a lot of good ideas here that I could (should) steal. I list some of those below.

*** TODO Normal movement keys to move through the outer layout, special keys to move within
He uses h-j-k-l to move through the outer layout, which behaves the same way as if without =subLayout=
When on a sublayout, he uses special keys - eg. =C-;= to move through the tabs in a tabbed sublayout.

** TODO Update prompts
The default prompt looks really ugly.
** TODO Find and fix space leaks, if any
I haven't been paying attention to the space leaks due to laziness, so there's at least a few in this code.
Use Neil Mitchell's [[https://neilmitchell.blogspot.com/2020/05/fixing-space-leaks-in-ghcide.html][technique]] for this. Should be goo
* Imports
Libraries for system IO actions
#+begin_src haskell
import System.IO (openFile)
import System.Posix.IO
import System.Posix.Types (CPid(..))
import System.Process (system, readProcess)
import System.Posix.Process (executeFile, getProcessID)
import System.Posix.Signals (signalProcess, sigKILL)
import Control.Concurrent (threadDelay)
import System.Environment (getArgs, getEnv)
import System.Exit (ExitCode(..))
import Control.Exception (try, displayException, SomeException)
import GHC.IO.Handle (hClose, hDuplicateTo)
import System.FilePath.Posix ((</>))
import System.Directory
import Data.Time
#+end_src

Some general libraries
#+begin_src haskell
import Relude as R
import Relude.Extra.Foldable1
import Relude.Extra.Tuple
import Relude.Extra.Bifunctor
import Relude.Extra.Map (member, lookup)
import qualified Relude.Unsafe as Unsafe
import qualified Prelude as P
import Data.Char
import qualified Data.Text as T
import qualified Data.Text.Lazy as TL
import Data.Function
import Data.List (elemIndex, foldr1)
#+end_src

Reverse application functions
#+begin_src haskell
import Flow
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad hiding (Color, whenJust)
import qualified XMonad.StackSet as W
#+end_src

Some utilities from =xmonad-contrib=
#+begin_src haskell
import XMonad.Util.Run
import XMonad.Layout.LayoutModifier (ModifiedLayout)
import XMonad.Util.Types
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Font (Align(..))
import XMonad.Actions.Submap (submap)
#+end_src

Change the cursor
#+begin_src haskell
import XMonad.Util.Cursor (setDefaultCursor, xC_left_ptr)
#+end_src

Easy formatting
#+begin_src haskell
import Text.Printf
import Data.Text.Format (Only(..))
import qualified Data.Text.Format as F
#+end_src

Some helpers for output and parsing
#+begin_src haskell
import XMonad.Config.Dmwit (outputOf)
#+end_src

Libraries for managing and logging to the status bar.
#+begin_src haskell
import XMonad.Hooks.DynamicLog (PP(..))
import XMonad.Hooks.DynamicBars
import XMonad.Hooks.ManageDocks (docks, avoidStruts, AvoidStruts)
#+end_src

Libraries for pretty-printing to the status bar
#+begin_src haskell
import XMonad.Util.WorkspaceCompare (getSortByIndex)
#+end_src

Library to listen for external messages
#+begin_src haskell
import XMonad.Hooks.ServerMode
#+end_src

X11 imports to send atoms to the server
#+begin_src haskell
import qualified Graphics.X11.Xlib as X11
import qualified Graphics.X11.Xlib.Extras as X11
#+end_src

Argument parsing library
#+begin_src haskell
import Options.Applicative
#+end_src

Rename workspaces
#+begin_src haskell
import XMonad.Actions.WorkspaceNames
#+end_src

Provide graphical prompts
#+begin_src haskell
import XMonad.Prompt
#+end_src

Move the mouse to where you want it
#+begin_src haskell
import qualified XMonad.Actions.Warp as Warp
#+end_src

Add/remove window decorations
#+begin_src haskell
import XMonad.Layout.Decoration
import XMonad.Layout.NoBorders
#+end_src

Some layouts
#+begin_src haskell
import XMonad.Layout.Tabbed
import XMonad.Layout.Simplest
#+end_src

Setting layout names
#+begin_src haskell
import XMonad.Layout.Renamed
#+end_src

* Utils
Some utility functions to make life easy

Markup and logging
#+begin_src haskell
wrap :: Text -> Text -> Text -> Text
wrap left right middle = left <> middle <> right

pad :: Text -> Text
pad = wrap " " " "

shorten :: Int -> Text -> Text
shorten maxlen text = case text `T.compareLength` maxlen of
  GT -> T.snoc (T.take maxlen text) ellipsis
  otherwise -> text
  where ellipsis = 'â€¦'

format fmt = TL.toStrict . F.format fmt
format1 str item = format str (Only item)

#+end_src


Parsing
#+begin_src haskell
withInfo opts desc = info (helper <*> opts) $ progDesc desc
#+end_src

Dealing with three-tuples
#+begin_src haskell
mapThd3 f (a,b,c) = (a,b, f c)
dropSnd3 (a,b,c) = (a,c)
dropThd3 (a,b,c) = (a,b)
#+end_src

Measuring timings
#+begin_src haskell
logDuration :: MonadIO m => m a -> m a
logDuration action = do
  startTime <- io getCurrentTime
  result <- action
  endTime <- io getCurrentTime
  putStrLn $ "Time taken: " ++ show (diffUTCTime endTime startTime)
  return result
#+end_src

Reverse function application for code "flow"
#+begin_src haskell
infixl 0 |>>
x |>> f = x |> fmap f
#+end_src

Layout naming - the most common use of =X.L.Renamed=
#+begin_src haskell
nameLayout newName = renamed [Replace newName]
#+end_src

XMonad installs =SIGCHLD= and =SIGPIPE= handlers which ignore these signals. This causes issues with some programs,
like =stack build=.
#+begin_src haskell
withoutSignalHandlers :: X a -> X a
withoutSignalHandlers action = do
  uninstallSignalHandlers
  result <- action
  installSignalHandlers
  return result
#+end_src

X accessors
#+begin_src haskell
withCurrentWorkspace :: (WorkspaceId -> X ()) -> X ()
withCurrentWorkspace action =
  withWindowSet (W.currentTag .> action)

withCurrentScreen :: (ScreenId -> X ()) -> X ()
withCurrentScreen action =
  withWindowSet (W.current .> W.screen .> action)
#+end_src
* Markup(s)
Define interfaces for markup languages used later.

** Dzen
First, dzen for the =which-key= popups.
dzen has a lot more formatting options, like rectangles, xbm icons, and whatnot.
Might be interesting to explore later.
#+begin_src haskell
type Color = Text

dzenFg, dzenBg :: Color -> Text -> Text
dzenFg color string = format "^fg({}){}^fg()" (color, string)
dzenBg color string = format "^bg({}){}^bg()" (color, string)
#+end_src

** Lemonbar
Enumerate the mouse buttons. We'll use the =Enum= instance to use it in the markup, but
since the default =Enum= instance starts counting from 0 and we want to start from 1, we'll have to add 1 to it.
#+begin_src haskell
data MouseButton
  = LeftClick
  | MiddleClick
  | RightClick
  | ScrollUp
  | ScrollDown
  | DoubleLeftClick
  | DoubleMiddleClick
  | DoubleRightClick
  deriving (Eq, Ord, Show, Enum)

fromMouseButton :: MouseButton -> Int
fromMouseButton = succ . fromEnum
#+end_src

Then we define the formatting possibilities in lemonbar markup.
#+begin_src haskell
data LemonbarFormatting
  = Foreground Color
  | Background Color
  | Reverse
  | Underline Color
  | Overline Color
  | Font Int
  | Offset Int
  | Action MouseButton Text
  deriving (Eq, Show)
#+end_src

And finally convert these to markup using the [[https://github.com/LemonBoy/bar#formatting][lemonbar formatting spec]].
#+begin_src haskell
lemonbarFormatOne :: LemonbarFormatting -> Text -> Text
lemonbarFormatOne fmt = case fmt of
  (Foreground color)      -> wrap (bracket $ format1 "F{}" color) (bracket "F-")
  (Background color)      -> wrap (bracket $ format1 "B{}" color) (bracket "B-")
  (Reverse)               -> wrap (bracket "R") (bracket "R")
  (Underline color)       -> wrap (bracket (format1 "u{}" color) <> bracket "+u") (bracket "-u")
  (Overline color)        -> wrap (bracket (format1 "o{}" color) <> bracket "+o") (bracket "-o")
  (Font index)            -> wrap (bracket (format1 "T{}" index)) (bracket "T-")
  (Offset size)           -> (bracket (format1 "O{}" size) <>)
  (Action button cmd)     -> wrap (bracket (format "A{}:{}:" (fromMouseButton button, (escape ':' cmd))))
                                  (bracket "A")
  where
    bracket = wrap "%{" "}"
    escape char =
      let charT = T.singleton char in
      T.replace charT (T.cons '\\' charT)

lemonbarFormat :: [LemonbarFormatting] -> Text -> Text
lemonbarFormat fmts = foldr (.) id (lemonbarFormatOne <$> fmts)
#+end_src

* Colors
** one-dark
#+begin_src haskell
onedarkBlack  = "#282c34"
onedarkRed    = "#e06c75"
onedarkGreen  = "#98c379"
onedarkYellow = "#e5c07b"
onedarkBlue   = "#61afef"
onedarkPurple = "#c678dd"
onedarkCyan   = "#56b6c2"
onedarkGrey   = "#abb2bf"

onedarkGreenDarker = "#68a349"
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

The =NamedActions= module already provides some of this functionality, but it shows /all/ the keybindings at once.
=which-key='s approach to this is to only show keybindings which have partially been completed.

As an example, let this be your config:
#+begin_example
[ ("C-u f", "use foo")
, ("C-u m", "use moo")
, ("C-u x", "use xoo")
, ("C-u r", "use roo")

, ("C-g f", "goto foo")
, ("C-g m", "goto moo")
, ("C-g x", "goto xoo")
, ("C-g r", "goto roo")

, ("C-i f", "info foo")
, ("C-i m", "info moo")
, ("C-i x", "info xoo")
, ("C-i r", "info roo")
]
#+end_example

=NamedActions= would provide a help bindings (such as "F1") that you could hit to see all of these at once.
In contrast, this implementation of =which-key= does not provide a help binding, but you could hit ~C-i~ (say) and the help
for keys which /complete/ C-i bindings would pop up after a delay (say, 2 seconds).
That would look like this:
#+begin_example
f -> info foo
m -> info moo
x -> info xoo
r -> info roo
#+end_example
I find this a lot better for discoverability, as seeing all bindings at once is a bit overwhelming.

We use =dzen= with some basic settings to display text on the screen. I would've liked to use =XMonad.Util.Dzen= for this,
but it only contains =X= actions, while we only have access to =IO= in some situations.
#+begin_src haskell
displayTextFont :: String
displayTextFont = "Iosevka:pixelsize=15"

displayTextSync :: MonadIO m => Maybe Int -> Text -> m ()
displayTextSync time text = io . void $ readProcess "dzen2"
  (("-p" : timeArg) ++
   [ "-l", show numLines
   , "-ta", "c" , "-sa", "c"
   , "-e", "onstart=uncollapse"                 -- show all lines at startup (by default they only show on mouse hover)
   , "-fn", displayTextFont
   ])
  (toString text)
  where
    numLines = max 0 (length (lines text) - 1)  -- we only count slave lines, so everything after the first one
    timeArg = maybeToList $ show <$> time

displayText time text = void $ xfork $ displayTextSync time text

displayTextSyncTill, displayTextTill :: MonadIO m => Int -> Text -> m ()
displayTextSyncTill = displayTextSync . Just
displayTextTill = displayText . Just

displayTextSyncForever, displayTextForever :: MonadIO m => Text -> m ()
displayTextSyncForever = displayTextSync Nothing
displayTextForever = displayText Nothing
#+end_src

We then need a pretty-printer for displaying the keybindings. The =NamedActions= module has functions for naming and
printing keybindings, but unfortunately it's too restrictive and doesn't allow any customization. I realized that
I don't require much of that functionality, and the provided pretty-printer is kind of ugly.
Let's define our own the pretty-printer first.
I'm using =equalizeLeft= and =equalizeRight= since we're using center-aligning in =dzen=, so the lines need to be of equal
length to match up.
#+begin_src haskell
data WhichkeyConfig
  = WhichkeyConfig
  { keyFg  :: Color     -- ^ foreground color for keys
  , descFg :: Color     -- ^ foreground color for action descriptions
  , delay  :: Rational  -- ^ delay (in seconds) after which whichkey pops up
  }

instance Default WhichkeyConfig where
  def = WhichkeyConfig
    { keyFg  = onedarkBlue
    , descFg = onedarkGreen
    , delay  = 1.5
    }

whichkeyShowBindings :: WhichkeyConfig -> [(Text, Text, X ())] -> [Text]
whichkeyShowBindings WhichkeyConfig{keyFg, descFg} keybinds =
  keybinds
  |>> dropThd3
  |>> first capitalizeIfShift
  |> unzip
  |> bimap equalizeLeft equalizeRight
  |> uncurry zip
  |>> bimap (dzenFg keyFg) (dzenFg descFg)
  |>> format "{} -> {}"
  where
    capitalizeIfShift keystr
      | "S-" `T.isPrefixOf` last3 = T.snoc (T.dropEnd 3 keystr) (toUpper lastChar)
      | otherwise = keystr
      where
        last3 = T.takeEnd 3 keystr
        lastChar = T.last last3

    equalizeLeft keys =
      let maxLen = maximum1 (T.length <$> T.empty :| keys) in
      T.justifyRight maxLen ' ' <$> keys

    equalizeRight descriptions =
      let maxLen = maximum1 (T.length <$> T.empty :| descriptions) in
      T.justifyLeft maxLen ' ' <$> descriptions
#+end_src

Like emacs' =which-key=, the help message should activate after a delay and close by itself if any key is pressed.
Let's define a custom submap function for that. For the reasons stated above, I'm using simple strings instead of the
=NamedActions= module here.
See [[opening-apps]] for a usage example.
*NOTE*: this might cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue,
since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: WhichkeyConfig
               -> XConfig l
               -> [(Text, Text, X ())]
               -> X ()
whichkeySubmap whichkeyConf config keybinds = do
  pid <- xfork (threadDelay (seconds $ delay whichkeyConf) >> displayTextSyncForever (toHelp keybinds))
  catchX (submap . mkKeymap config $ first toString . dropSnd3 <$> keybinds) mempty
  io $ signalProcess sigKILL pid
  spawn "pkill dzen2"
  where
    toHelp = unlines . whichkeyShowBindings whichkeyConf
#+end_src

* Client-Server
Using =X.H.ServerMode= allows us to control XMonad externally.
This allows for executing commands from the status bar, external prompts like =albert= etc.

=ServerMode='s actions are of the type =X ()=. This prevents them from taking any input, which reduces its usability
(eg. for switching workspaces, the workspace name needs to be taken as input).
There's two ways to solve this:
1. Create a different listener for each command that needs an input.
2. Take the first word as the name of the command and the rest as arguments.

The second solution has an implicit failure state (when the input string is empty), but probably much less wasteful.
This is the one that's used here. We enforce that the string is not empty through the command-line parser.

** Client
We first write the client which can send commands to the server.

The server listens for particular "addresses" that we can send arguments to.
We represent this with a simple datatype.
#+begin_src haskell
data Command = Command { addr :: String, command_ :: String, input :: [String] }
#+end_src

This code is modified from the documentation of =ServerMode=.
I don't understand all of this, but it should /Just Work(TM)/
#+begin_src haskell
sendCommand :: Command -> IO ()
sendCommand Command{addr, command_, input} = do
  let joinedInput = P.unwords (command_:input)
  display <- X11.openDisplay ""
  rootWin <- X11.rootWindow display $ X11.defaultScreen display
  addrAtom <- X11.internAtom display addr False
  msgAtom <- X11.internAtom display joinedInput False
  X11.allocaXEvent $ \event -> do
                  X11.setEventType event X11.clientMessage
                  X11.setClientMessageEvent event rootWin addrAtom 32 msgAtom X11.currentTime
                  X11.sendEvent display rootWin False X11.structureNotifyMask event
                  X11.sync display False
#+end_src
** Server
#+PROPERTY: header-args :tangle "Main.hs"

We define a list of commands that can be called.
For now we'll just define a command to switch to the appropriate workspace for use in the status bar.
#+begin_src haskell
serverCommands :: XConfig l -> [(String, String -> X ())]
serverCommands config =
  [ ("switch", cursorSwitchWorkspace)
  , ("refresh", const refresh)
  ]
#+end_src

=ServerMode= defaults this address to ="XMONAD_COMMAND"=. Since we're using the second method,
there's no real reason to change this or use multiple addresses.
#+begin_src haskell
serverAddress :: String
serverAddress = "XMONAD_COMMAND"
#+end_src

Then we need to define a function to split the input and lookup the appropriate action to take.
#+begin_src haskell
serverCallCommand :: Map String (String -> X ()) -> String -> X ()
serverCallCommand commandMap input =
  case lookup command commandMap of
    Just action -> action input'
    Nothing     -> io $ hPutStrLn stderr $ printf "Command '%s' not found" command
  where
    (command, input') = second (drop 1) $ break (== ' ') input
#+end_src

Finally, we set up the listener.
#+begin_src haskell
serverListenerHook :: XConfig l -> Event -> X All
serverListenerHook config =
  let commands = fromList (serverCommands config) in
  serverModeEventHookF serverAddress (serverCallCommand commands)
#+end_src

For convenience, we provide a command to add this functionality to a config.
#+begin_src haskell
serverEnable :: XConfig l -> XConfig l
serverEnable config@XConfig{handleEventHook} = config
  { handleEventHook = handleEventHook <+> serverListenerHook config }
#+end_src

*** Switch workspaces
While the staple =StackSet.view= and =StackSet.greedyView= work well enough for the server's ="switch"= action, it has
some unintuitive behaviour in case of multiple monitors.
Imagine there are two monitors and you click the workspace button on the status bar on the unfocused monitor -
this would activate the workspace on the active monitor, which is not the desired behaviour.
If the workspace you click on is the one that's focused on the foucsed monitor, then you probably want that
workspace to be focused on this monitor.
In both cases, the monitor the cursor is on is the one that's expected to be focused, so we should do this first.
Then, as seen in the second case, we should always put the selected workspace on this monitor, so we should use
=greedyView= rather than =view=.

Accordingly, first, an action to focus the workspace the cursor is on.
#+begin_src haskell
focusCursor :: X ()
focusCursor = void $ runMaybeT $ do
  pos <- MaybeT $ reader mousePosition
  workspace <- W.tag . W.workspace <$> MaybeT (uncurry pointScreen pos)
  lift $ windows $ W.view workspace
#+end_src

Then view the selected workspace on this monitor.
#+begin_src haskell
cursorSwitchWorkspace :: WorkspaceId -> X ()
cursorSwitchWorkspace workspace = do
  focusCursor
  windows $ W.greedyView workspace
#+end_src

* Polybar
[[https://github.com/polybar/polybar][Polybar]] is pretty cool. It has a lot of efficient modules for most things and is quite customizable.
Aside from the actual choice of bar, there are things I want from a status bar:
1. Show workspaces, Layout, extras etc. with nice highlighting
2. Workspace indicators on the bar should focus that workspace on being clicked
3. Different highlighting for bars on unfocused monitors
4. On adding or removing a monitor, bars should be added or deleted automatically

The first of these requirements is pretty standard, and can be achieved using some =lemonbar= markup that Polybar uses.

The second can be achieved with =xdotool set_desktop <workspace>=. This requires EWMH compliance which can be achieved
with =X.H.EwmhDesktops=.
The other option is to use =X.H.ServerMode= which allows us to call arbitrary actions from the bar, like changing the
layout. This is slightly more complicated, but should be worth it for the extensibility. This is the option used here.
A major downside of this approach is that it is slow - taking up to a second sometimes. Some logging reveals that the
message passing is the bottleneck, and there isn't much that can be done about that. Switching to the =xdotool= approach
is thus quite attractive, but has the downside that the action that can be taken is much simpler (equivalent to a
=StackSet.view=) and somewhat unintuitive. Since I don't use this too much, I'll let this be for now.

The third and fourth can be achieved with =X.H.DynamicBars=.

** Workspace switch buttons
Since polybar can be formatted to call scripts on click, we need to write a function which messages the
server to switch to the workspace clicked on and include it in our pretty printer.
This function needs to be the first to run on the workspace name, since it needs access to the unaltered
name to switch to it. It should also pad the name so that it's easy to click.
#+begin_src haskell
workspaceSwitcher :: WorkspaceIdT -> Text -> Text
workspaceSwitcher workspace =
  lemonbarFormat [Action LeftClick switchCommand] . pad
  where
    switchCommand = format1 "bin/launch client switch '{}'" workspace
#+end_src

** Workspace names
We use =X.A.WorkspaceNames= to show the custom names set on each workspace.
While the =WorkspaceNames= provides a function to modify a =PP= to use show these names automatically, it creates
problems with composability since it needs the first access to the real workspace name (similar to =workspaceSwitcher=)
Thus we change it to take a workspace name and produce a text modifier.

#+begin_src haskell
workspaceNamer :: X (WorkspaceIdT -> Text -> Text)
workspaceNamer = do
  names <- getWorkspaceNames'
  let namesT ws = ws |> toString |> names |>> toText
  return $ \ws ->
    case namesT ws of
      Nothing -> id
      Just name -> (<> ":" <> name)
#+end_src

** Pretty-printing
First, some code to switch between text and string
#+begin_src haskell
type WorkspaceIdT = Text

data PPText = PPText
  { pptCurrent :: WorkspaceIdT -> Text
  , pptVisible :: WorkspaceIdT -> Text
  , pptHidden  :: WorkspaceIdT -> Text
  , pptHiddenNoWindows :: WorkspaceIdT -> Text
  , pptVisibleNoWindows :: Maybe (WorkspaceIdT -> Text)
  , pptUrgent :: WorkspaceIdT -> Text
  , pptSep :: Text
  , pptWsSep :: Text
  , pptTitle :: Text -> Text
  , pptTitleSanitize :: Text -> Text
  , pptLayout :: Text -> Text
  , pptOrder :: [String] -> [String]
  , pptSort :: X ([WindowSpace] -> [WindowSpace])
  , pptExtras :: [X (Maybe Text)]
  , pptOutput :: Text -> IO ()
  }

ppTextToString :: PPText -> PP
ppTextToString ppt = PP
  { ppCurrent = convert $ pptCurrent ppt
  , ppVisible = convert $ pptVisible ppt
  , ppHidden  = convert $ pptHidden ppt
  , ppHiddenNoWindows = convert $ pptHiddenNoWindows ppt
  , ppVisibleNoWindows = convert <$> pptVisibleNoWindows ppt
  , ppUrgent = convert $ pptUrgent ppt
  , ppSep = toString $ pptSep ppt
  , ppWsSep = toString $ pptWsSep ppt
  , ppTitle = convert $ pptTitle ppt
  , ppTitleSanitize = convert $ pptTitleSanitize ppt
  , ppLayout = convert $ pptLayout ppt
  , ppOrder = pptOrder ppt
  , ppSort = pptSort ppt
  , ppExtras = (fmap . fmap . fmap) toString $ pptExtras ppt
  , ppOutput = pptOutput ppt . toText
  }
  where convert f = toString . f . toText

ppStringToText :: PP -> PPText
ppStringToText pp = PPText
  { pptCurrent = convert $ ppCurrent pp
  , pptVisible = convert $ ppVisible pp
  , pptHidden  = convert $ ppHidden pp
  , pptHiddenNoWindows = convert $ ppHiddenNoWindows pp
  , pptVisibleNoWindows = convert <$> ppVisibleNoWindows pp
  , pptUrgent = convert $ ppUrgent pp
  , pptSep = toText $ ppSep pp
  , pptWsSep = toText $ ppWsSep pp
  , pptTitle = convert $ ppTitle pp
  , pptTitleSanitize = convert $ ppTitleSanitize pp
  , pptLayout = convert $ ppLayout pp
  , pptOrder = ppOrder pp
  , pptSort = ppSort pp
  , pptExtras = (fmap . fmap . fmap) toText $ ppExtras pp
  , pptOutput = ppOutput pp . toString
  }
  where convert f = toText . f . toString


instance Default PPText where
  def = ppStringToText def
#+end_src

The basic pretty-printer which the upcoming ones should override.
#+begin_src haskell
basicPP :: PPText
basicPP = def
  { pptSep = "  "
  , pptWsSep = " "
  , pptTitleSanitize = T.filter (`notElem` ['%','{','}'])
  , pptOrder = layoutFirstOrder
  , pptSort = getSortByIndex
  , pptExtras = []
  , pptOutput = const mempty
  }
  where
    layoutFirstOrder (workspaces : layout : title : extras) =
      [layout] ++ extras ++ [workspaces, title]
    layoutFirstOrder other = other
#+end_src


When using multiple PP modifiers that need access to the real workspace name, we need a function to supply it to them
This requires the modifier functions to be changed to accept an additional workspace argument.
We make sure that the modifier functions are applied in the same order as provided in the list to main intuitiveness.
#+begin_src haskell
withRealWorkspaceName :: [X (WorkspaceIdT -> Text -> Text)] -> PPText -> X PPText
withRealWorkspaceName modifiers ppt@PPText{..} = do
  mod <- finalModifier
  pure $ ppt
   { pptCurrent = pptCurrent . mod
   , pptVisible = pptVisible . mod
   , pptHidden = pptHidden . mod
   , pptUrgent = pptUrgent . mod
   , pptHiddenNoWindows = pptHiddenNoWindows . mod
   , pptVisibleNoWindows = fmap (. mod) pptVisibleNoWindows
   }
  where
    modifiers' = reverse modifiers

    finalModifier :: X (Text -> Text)
    finalModifier = do
      mods <- sequence modifiers'
      pure \ws ->
        mods
        |> fmap ($ ws)
        |> foldr (.) id
        |> ($ ws)
#+end_src

This is the one that finally gets applied.
#+begin_src haskell
chosenPP :: (X PP, X PP)
chosenPP = (onedarkFocusedPP, onedarkUnfocusedPP)
           |> bimapBoth (withRealWorkspaceName
                           [ workspaceNamer
                           , workspaceSwitcher'
                           ])
           |> bimapBoth (fmap ppTextToString)
  where
   workspaceSwitcher' = pure workspaceSwitcher
#+end_src

*** one-dark
#+begin_src haskell
onedarkFocusedPP :: PPText
onedarkFocusedPP = basicPP
  { pptCurrent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkGreen, Underline onedarkGreenDarker ]
  , pptVisible = lemonbarFormat [ Foreground onedarkGreen, Background onedarkGrey, Underline onedarkGreen ]
  , pptVisibleNoWindows = Just $
      lemonbarFormat [ Foreground onedarkBlack, Background onedarkGrey, Underline onedarkGreen ]
  , pptHidden = lemonbarFormat [ Foreground onedarkGreen, Underline onedarkGreen ]
  , pptHiddenNoWindows = lemonbarFormat [ Foreground onedarkGrey ]
  , pptUrgent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkRed ]
  , pptTitle = lemonbarFormat [ Foreground onedarkGrey ] . shorten 50
  , pptLayout = lemonbarFormat [ Foreground onedarkYellow ]
  }

onedarkUnfocusedPP :: PPText
onedarkUnfocusedPP = onedarkFocusedPP
  { pptCurrent = Unsafe.fromJust $ pptVisibleNoWindows onedarkFocusedPP
  , pptVisible = pptHiddenNoWindows onedarkFocusedPP
  , pptVisibleNoWindows = Just $ pptHiddenNoWindows onedarkFocusedPP
  , pptHidden = pptHiddenNoWindows onedarkFocusedPP
  }
#+end_src

** Dynamic bar highlighting and management
=DynamicBars= asks for a bar startup function of the type =ScreenId -> IO Handle=, where =ScreenId= is simply a newtype for
=Int=. On the other hand, Polybar requires an xrandr monitor name to know which screen to use. So first we need a
mapping between the two.
I simply use =xrandr= to query which monitors are active and hope to dear god that they are in the same order as the
=ScreenId='s. So far I have not been let down.
#+begin_src haskell
monitorIds :: IO [(ScreenId, Text)]
monitorIds = do
  output <- toText <$> outputOf "xrandr --listactivemonitors 2>/dev/null | awk '{print $1 $4}'"
  return $ mapMaybe parseMonitor . drop 1 $ lines output
  where
    parseMonitor :: Text -> Maybe (ScreenId, Text)
    parseMonitor text = do
      let (idText, monitorText) = T.breakOn ":" text
      monitor <- T.stripPrefix ":" monitorText
      id <- readMaybe . toString $ idText
      return (S id, monitor)
#+end_src

We want to use =spawnPipe= to start polybar and pass input to its stdin, but unfortunately polybar doesn't read from
there. So we need to use an intermediary to pass it into polybar through a named pipe. We /could/ do this from xmonad
itself, but then we have to maintain consistency between xmonad and polybar about the name of the pipe. That, and
using named pipes in haskell turns out to have a lot of gotchas.
We do this through a shell script =polybar-start-monitor.sh=

The relevant polybar module just reads a the passed environment variable =STDINFIFO=
#+begin_src conf :tangle no
[module/stdin]
type = custom/script
tail = true
exec = cat $STDINFIFO
#+end_src

And finally the startup and cleanup functions for the bar.
#+begin_src haskell
polybarStartup :: ScreenId -> IO Handle
polybarStartup screenId = do
  monitors <- monitorIds
  case P.lookup screenId monitors of
    Just monitor -> spawnPipe . toString $ format1 "bin/polybar-start-monitor.sh {}" monitor
    Nothing -> error $ format "No monitor found for {} in {}" (P.show screenId, P.show monitors)

polybarCleanup :: IO ()
polybarCleanup = do
  (CPid pid) <- getProcessID
  spawn $ printf "pkill --parent %d bin/polybar-start-monitor.sh" pid
#+end_src

And then plumb everything together with =DynamicBars= and =ManageDocks= (to actually make space for the bar).
#+begin_src haskell
polybarEnable :: XConfig Layout -> XConfig Layout
polybarEnable config@XConfig{..}  =
  case layoutHook of
    Layout layout ->
      docks $ config
        { startupHook     = startupHook      <+> dynStatusBarStartup polybarStartup polybarCleanup
        , handleEventHook = handleEventHook  <+> dynStatusBarEventHook polybarStartup polybarCleanup
        , logHook         = logHook          <+> multiPP' chosenPP
        , layoutHook      = Layout $ avoidStruts $ layout
        }
        where multiPP' (pp1, pp2) = join $ multiPP <$> pp1 <*> pp2
#+end_src

* Workspaces
** Static & Freeform
Static workspaces - each one dedicated to a specific purpose - is often too restrictive. However, having a few with
predefined purposes (todos, music, messaging etc.) makes it easy to manage and switch to them. In the past, I've
worked with 12 workspaces - 7 of them free-form and 5 predefined. This worked quite well.
#+begin_src haskell
data WorkspaceType = Predefined | Freeform
  deriving (Eq, Ord, Show)
#+end_src

Finally, we set the names for the predefined workspaces.
Here these are fontawesome unicode names which /should/ indicate their purpose.
#+begin_src haskell
wsTodo  = "\xf00b"
wsConf  = "\xf992"
wsEntt  = "\xf880"
wsMusic = "\xf001"
wsComms = "\xf086"
#+end_src

Then we need to define the workspace in the order of the keys used to access them.
We use the number row for this purpose.
#+begin_src haskell
myWorkspaceKeys = ["0"] ++ fmap show [1..9] ++ ["-", "="]

myWorkspaces :: [(WorkspaceType, WorkspaceId)]
myWorkspaces =
     [ (Predefined, wsTodo) ]
  ++ ( (Freeform,) . show <$> [1..7] )
  ++ [ (Predefined, wsConf)
     , (Predefined, wsEntt)
     , (Predefined, wsMusic)
     , (Predefined, wsComms)
     ]

#+end_src

We then derive the rest we need.
#+begin_src haskell
myPredefinedWorkspaces :: Set WorkspaceId
myPredefinedWorkspaces =
  myWorkspaces
  |> filter ((Predefined ==) . fst)
  |>> snd
  |> fromList

myWorkspaceStrings :: [String]
myWorkspaceStrings = snd <$> myWorkspaces

myWorkspacesWithKeys = zip myWorkspaceKeys myWorkspaceStrings

isPredefinedWorkspace :: WorkspaceId -> Bool
isPredefinedWorkspace ws = ws `member` myPredefinedWorkspaces
#+end_src

** Naming
Naming workspaces helps immensely in identifying them just from the status bar, and thus managing them.
This only makes sense for freeform workspaces though.

We need a prompt for reading the workspace name with =renameWorkspace=.
Let's just use the default for the time being.
#+begin_src haskell
renamePrompt :: XPConfig
renamePrompt = def
#+end_src

We also make sure that only the freeform workspaces can be named.
#+begin_src haskell
renameWorkspace' :: XPConfig -> X ()
renameWorkspace' prompt = withCurrentWorkspace $ \ws ->
  unless (isPredefinedWorkspace ws)
    (renameWorkspace prompt)
#+end_src

We also provide a utility action to remove the workspace name
#+begin_src haskell
removeCurrentWorkspaceName :: X ()
removeCurrentWorkspaceName = setCurrentWorkspaceName ""
#+end_src

We include these actions in =workspaceKeys= to use them.

** TODO Groups
* Layouts
Since all layouts have different types, we wrap our layout choices in existentials to be able to keep them in a list.
This enables different parts different parts of the config to pick up which layouts are in use without having to
specify them in each place.
NOTE: This should never be empty.
#+begin_src haskell
myLayouts :: [Layout Window]
myLayouts = [Layout myTall, Layout myTabbed]
#+end_src

** Launch using existential layouts
We have to fold over the layouts to combine them into one.
#+begin_src haskell
myLayoutHook :: Layout Window
myLayoutHook = foldr1 (\(Layout a) (Layout b) -> Layout (a ||| b)) myLayouts
#+end_src

=launch= doesn't accept an existential layout hook, so we must unwrap it to pass it.
All config modifiers must also be specifically written to be of type =XConfig Layout -> XConfig Layout= instead of a
general =XConfig l1 -> XConfig l2=. The modifiers are applied in the same order as they appear,
so modifiers =[f_1, f_2, f_3]= would be applied as =f_3 (f_2 (f_1 config))=
#+begin_src haskell
launchWithModifications :: [XConfig Layout -> XConfig Layout] -> XConfig Layout -> IO ()
launchWithModifications modifications config =
  case layoutHook modifiedConfig of
    Layout layoutHook' -> launch $ modifiedConfig { layoutHook = layoutHook' }
  where modifiedConfig = foldr ($) config (reverse modifications)
#+end_src

** Tab bar decorations
*** Layouts like Tall
Tab bar decorations look cleaner than borders in a lot of layouts. It also makes it possible to easily tell which
window is active without using gaps, since borders are shared between adjoining windows.
The existing solutions for this are =X.L.TabBarDecoration= and =X.L.Tabbed=.
However, both of them have their downsides:
- =TabBarDecoration=: Can only be applied on top or bottom (not left or right).
                    Cannot be made smart (in the sense of =smartBorders=).
- =Tabbed=: This module is more for using a tabbed sublayout in another layout rather than just the decoration.
          While there is support for "smart" behaviour in this module, it doesn't work /quite/ like I'd hoped.
          My misunderstanding is captured in this [[https://www.reddit.com/r/xmonad/comments/cm8pt4/addtabs_doesnt_show_tabs_with_tall/][post]].

My decision was to write my own simple =DecorationStyle= for this - turned out it wasn't that hard.
#+begin_src haskell
data SmartTabAddonDeco a = SmartTabAddonDeco Direction2D
  deriving (Eq, Show, Read)

shrinkWinForDeco direction =  case direction of
  U -> shrinkUp
  D -> shrinkDown
  L -> shrinkLeft
  R -> shrinkRight
  where
    shrinkUp    (Rectangle _ _ _ dh) (Rectangle x y w h) = Rectangle x (y + fi dh) w (h - fi dh)
    shrinkDown  (Rectangle _ _ _ dh) (Rectangle x y w h) = Rectangle x y w (h - fi dh)
    shrinkLeft  (Rectangle _ _ dw _) (Rectangle x y w h) = Rectangle (x + fi dw) y (w - fi dw) h
    shrinkRight (Rectangle _ _ dw _) (Rectangle x y w h) = Rectangle x y (w - fi dw) h


instance Eq a => DecorationStyle SmartTabAddonDeco a where
  shrink (SmartTabAddonDeco direction) = shrinkWinForDeco direction

  pureDecoration (SmartTabAddonDeco direction) decoWidth decoHeight _ _ windowRects currentWin@(_win, Rectangle x y w h)
    | length windowRects >= 2 = Just smartTabBar
    | otherwise               = Nothing
    where
      smartTabBar = case direction of
        U -> Rectangle x y w decoHeight
        D -> Rectangle x (y + fi (h - decoHeight)) w decoHeight
        L -> Rectangle x y decoWidth h
        R -> Rectangle (x + fi (w - decoWidth)) y decoWidth h
#+end_src

The tabs are probably going to be too small to show window titles, and it doesn't make sense in case of left and
right tabs, we change the shrinker to not display any text.
#+begin_src haskell
data EmptyShrinker = EmptyShrinker
  deriving (Read, Show)

instance Shrinker EmptyShrinker where
  shrinkIt _ _ = []
#+end_src


We use a simple function to add tabs and remove borders.
#+begin_src haskell
smartTabAddonDeco direction theme tabWidth = noBorders . decoration shrinker theme' (SmartTabAddonDeco direction)
  where
    shrinker = EmptyShrinker
    theme' = theme { decoHeight = tabWidth, decoWidth = tabWidth }
#+end_src

*** Tabbed
Originally I planned to only use my own decoration for layouts like =Tall= - where these decorations need to be
displayed for all /visible/ windows. I was planning to use =X.L.Tabbed= for a tabbed layout and have it display its
own decorations, where I like having the decorations pop up on the left with =tabbedLeft=. I expected that the
decorations will fill up the entire height, however this turns out not to be the case (although I could swear this
used to work like that in the past). The decorations take up only the size specified by =decoHeight= and =decoWidth=.
So we need another custom decorator.

It was hard to come up with a name that disambiguates this from the previous decorator.
#+begin_src haskell
data SmartTabbedDeco a = SmartTabbedDeco Direction2D
  deriving (Eq, Read, Show)
#+end_src

The window shrinking logic should be the same as before.
The decoration rectangle is also mostly the same. We decide whether to display one based on how many windows
there are in the stack rather than the displayed ones (since =Tabbed= only displays one window at once) and divide
the screen height/width into equal parts for each window decoration.
#+begin_src haskell
instance Eq a => DecorationStyle SmartTabbedDeco a where
  shrink (SmartTabbedDeco direction) = shrinkWinForDeco direction

  pureDecoration (SmartTabbedDeco direction) decoWidth decoHeight _ stack _ (currentWin, Rectangle x y w h)
    | numWins >= 2 = Just smartTabBar
    | otherwise    = Nothing
    where
      stackList = W.integrate stack
      numWins = length stackList

      smartTabBar = case direction of
        U -> Rectangle (x + fi winIdx * fi splitWidth) y splitWidth decoHeight
        D -> Rectangle (x + fi winIdx * fi splitWidth) (y + fi (h - decoHeight)) splitWidth decoHeight
        L -> Rectangle x (y + fi winIdx * fi splitHeight) decoWidth splitHeight
        R -> Rectangle (x + fi (w - decoWidth)) (y + fi winIdx * fi splitHeight) decoWidth splitHeight

      splitHeight = h `div` fi numWins
      splitWidth  = w `div` fi numWins
      winIdx = fromMaybe 0 $ elemIndex currentWin stackList -- this should never be Nothing
#+end_src

A simple utility function to apply this decoration:
#+begin_src haskell
smartTabbedDeco direction theme tabWidth = noBorders . decoration EmptyShrinker theme' (SmartTabbedDeco direction)
  where theme' = theme { decoHeight = tabWidth, decoWidth = tabWidth }
#+end_src

*** Theme(s)
We use a single tab theme to stay consistent across layouts.
Since the tab decoration is highlighted, there isn't a need for the border.
#+begin_src haskell
myTabTheme :: Theme
myTabTheme = def
  { activeColor         = activeColor
  , activeBorderColor   = activeColor
  , inactiveColor       = inactiveColor
  , inactiveBorderColor = inactiveColor
  , urgentColor         = urgentColor
  , urgentBorderColor   = urgentColor
  , decoHeight          = 5
  , decoWidth           = 5
  }
  where
   activeColor = toString onedarkBlue
   inactiveColor = toString onedarkBlack
   urgentColor = toString onedarkRed
#+end_src

** Tall layout
#+begin_src haskell
myTall =
  nameLayout "Tall"
  $ smartTabAddonDeco U myTabTheme 5
  $ Tall
    { tallNMaster = 1
    , tallRatioIncrement = 1/100
    , tallRatio = 1/2
    }
#+end_src

** Tabbed layout
I wanted to use =X.L.Tabbed= here, but as described in [[Tab bar decorations/Tabbed]] section, its tab decorations do not
span over the whole height in =tabbedLeft= and =tabbedRight=. The =Tabbed= layout is just a simple wrapper over =Simplest=
that sets a decorator, so this should be more or less equivalent.
#+begin_src haskell
myTabbed =
  nameLayout "Tabbed"
  $ smartTabbedDeco L myTabTheme 5
  $ Simplest
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , keys            = myKeymap
  , mouseBindings   = myMouseBindings
  , startupHook     = myStartupHook
  , workspaces      = myWorkspaceStrings
  , layoutHook      = myLayoutHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

setTestModMask config = config { modMask = testModMask }
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys

myKeys :: [(String, X ())]
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  , infoKeys
  , workspaceKeys
  ]
#+end_src

Some quick helper functions
#+begin_src haskell
spawnKeymap :: Text -> [(Text, Text, String)] -> (String, X ())
spawnKeymap key items = (toString key, whichkeySubmap def myConfig $ mapThd3 spawn <$> items)
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  , ("M-<Space>", sendMessage NextLayout)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~,
but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = return $ spawnKeymap "M-u" apps
  where
    apps = [ ("t"  , "Terminal"    , terminal myConfig)
           , ("e"  , "Emacs Client", "emacsclient -c")
           , ("S-e", "Emacs"       , "emacs")
           , ("f"  , "Firefox"     , "firefox")
           , ("r"  , "Ranger"      , "$TERMINAL ranger")
           , ("w"  , "WhatsApp"    , "whatsapp.sh")
           ]
#+end_src

*** Info keys
Keys for referring to information quickly - latex symbols, nerdfont icons etc.
#+begin_src haskell
infoKeys = return $ spawnKeymap "M-i" info
  where
    info = [ ("n"  , "Nerdfont reference"      , "nerdfont-dmenu.sh")
           , ("l"  , "LaTeX symbol reference"  , "xdg-open http://detexify.kirelabs.org/classify.html")
           , ("x m", "xmonad reference"        , "xdg-open https://hackage.haskell.org/package/xmonad")
           , ("x c", "xmonad-contrib reference", "xdg-open https://hackage.haskell.org/package/xmonad-contrib")
           ]
#+end_src

*** Workspace keys
Keys for managing workspaces

When changing focus to a workspace on a multi-monitor setup, it's rare that you want to keep the cursor in the
previous position; so we put it in the middle of the screen.
#+begin_src haskell
placeCursorMiddle = withCurrentScreen \screen ->
  Warp.warpToScreen screen (1/2) (1/2)
#+end_src

I find the behaviour of =StackSet.view= a lot more intuitive than =StackSet.greedyView= - the unexpected workspace
swapping is a bit jarring. Thus we arrive at a workspace view action:
#+begin_src haskell
viewWorkspace ws = do
  windows (W.view ws)
  placeCursorMiddle
#+end_src

Shifting a window to another workspace should have similar behaviour.
#+begin_src haskell
viewShift ws = do
  windows (W.shift ws)
  viewWorkspace ws
#+end_src

Swapping a workspace is sometimes a necessary evil; it's mostly required when there's a lot of workspaces and you
need to manually reorder them according to some idea of similarity. As such, it facilitates the manual ordering of
workspaces that I would rather get rid of in other ways (viz. workspace groups); thus I do not include it in the
keys. If someone wants it, =X.A.WorkspaceNames.swapWithCurrent= is your friend :)

So finally, the keys are:
#+begin_src haskell
workspaceKeys = viewKeys ++ shiftKeys ++
  [ ("M-r"  , renameWorkspace' renamePrompt)
  , ("M-S-r", removeCurrentWorkspaceName)
  ]
  where
    workspaceFun :: String -> (WorkspaceId -> X ()) -> [(String, X ())]
    workspaceFun prefix action =
      first (prefix <>) . second action <$> myWorkspacesWithKeys

    viewKeys  = workspaceFun "M-"   viewWorkspace
    shiftKeys = workspaceFun "M-S-" viewShift
#+end_src

** Mouse bindings
Let's keep this empty for now. The default behaviour of making windows floating when dragged around is really
irritating.
#+begin_src haskell
myMouseBindings :: XConfig Layout -> Map (ButtonMask, Button) (Window -> X ())
myMouseBindings config = fromList []
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of
=myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
The default cursor is also... not the best - change it to something more standard.
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
    setDefaultCursor xC_left_ptr
#+end_src

* Running
** Restarting
=restartConfig= copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
Using =SomeException= catches all exceptions
#+begin_src haskell
buildConfig :: X Bool
buildConfig =
  (io (try (system "bin/build") :: IO (Either SomeException ExitCode)))
  >>= \case
    Right ExitSuccess -> return True
    otherwise -> return False

restartConfig :: Bool -> X ()
restartConfig resume =
  withoutSignalHandlers $
  whenX buildConfig $ do
    broadcastMessage ReleaseResources
    io . flush =<< asks display
    when resume writeStateToFile
    origArgs <- io getArgs
    catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Logging
There's two ways to view xmonad logs. Either you set =exec <xmonad executable>= in your =.xinitrc= and redirect the logs
of your X session with =startx &> <logfile>=. The other, cleaner way, is to tell hardcode the path in =xmonad= itself.
This way you're free to start your session however and not capture /all/ the logs.

This [[https://www.reddit.com/r/xmonad/comments/cr0ry3/viewing_stderr_from_stack_config/exkkmie/][code]] accomplishes this, courtesy of [[https://www.reddit.com/user/simonfxr/][u/simonfixr]].
#+begin_src haskell
redirectStdHandles :: FilePath -> IO ()
redirectStdHandles directory = do
  createDirectoryIfMissing True directory
  hClose stdout
  hClose stderr
  stdout' <- openFile (directory </> "xmonad-stdout.log") WriteMode
  stderr' <- openFile (directory </> "xmonad-stderr.log") WriteMode
  hDuplicateTo stdout' stdout
  hDuplicateTo stderr' stderr

redirectLogs :: FilePath -> XConfig l -> XConfig l
redirectLogs directory conf@XConfig{startupHook} =
  conf { startupHook = io (redirectStdHandles directory) >> startupHook }
#+end_src

** Argument parsing
We need to handle arguments to disambiguate between three cases:
1. Main: running XMonad as a WM (and a server)
2. Test: running XMonad in a test environment
3. Client: running as a client to send a message to the XMonad server

We represent this as an ADT.
#+begin_src haskell
data Executable = XMonad { testing :: Bool } | Client Command
#+end_src

The XMonad parser is quite simple.
#+begin_src haskell
xmonadParser :: Parser Executable
xmonadParser = XMonad
  <$> switch (long "test" <> help "Run XMonad in a test environment" )
#+end_src

The client parser is a bit more involved
#+begin_src haskell
clientParser :: Parser Executable
clientParser = Client <$> commandParser

commandParser :: Parser Command
commandParser = Command
                <$> strOption
                      (help "Target address for the command"
                       <> short 'a'
                       <> long "addr"
                       <> metavar "ADDR"
                       <> value serverAddress
                       <> showDefault)
                <*> strArgument
                      (help "The command to call"
                       <> metavar "COMMAND")
                <*> many
                      (strArgument
                        (help "Arguments for the command"
                         <> metavar "ARGS"))
#+end_src

Finally we separate these two.
#+begin_src haskell
mainParser :: Parser Executable
mainParser = subparser $ mconcat
  [ command "start"  (xmonadParser `withInfo` "Start XMonad")
  , command "client" (clientParser `withInfo` "Send a message to the XMonad server")
  ]

parseArguments :: IO Executable
parseArguments = execParser (mainParser `withInfo` "Interact with XMonad")
#+end_src

** Main
We define the interpreters for each possible usage.
#+begin_src haskell
runXMonad config
    = launchWithModifications [polybarEnable, serverEnable] config

runExecutable :: Executable -> IO ()
runExecutable (XMonad { testing = False })
    = runXMonad
    $ redirectLogs "/tmp"
    $ myConfig

runExecutable (XMonad { testing = True })
    = runXMonad
    $ setTestModMask
    $ myConfig

runExecutable (Client command)
    = sendCommand command
#+end_src

Finally, we run the parser and interpret the result.
#+begin_src haskell
main :: IO ()
main = parseArguments >>= runExecutable
#+end_src

# Local Variables:
# fill-column: 120
# End:
