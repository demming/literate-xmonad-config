#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"
#+TODO: TODO IDEA | DONE

* Ideas & Fixes
** IDEA Workspace-aware browser launcher
Credit: [[https://github.com/altercation/dotfiles-tilingwm/blob/31e23a75eebdedbc4336e7826800586617d7d27d/.xmonad/xmonad.hs#L406][Ethan Schoonover]]
I could configure the browser launcher to select particular profiles or tabs to start with - based on the workspace.
Since most of my workspaces are generic, using workspace names to decide might be a good idea.
This could be a significant gain.

#+begin_example
workspace name = "grading" --> tabs: <gradescope> <gmail/.jobs>
workspace name = "config" --> tabs: <xmonad> ...
#+end_example

** TODO Translate some keys to Firefox shortcuts when it is open
I've used this in a previous setup, and it works amazingly well.
** IDEA Convert this to a literate haskell file while maintaining org syntax
Pros:
- Provides editor support for haskell --> this is a /huge/ benefit
- Can split up files, if required
- No tangling required

Cons:
- Possibly removes editor support for org-mode
- Doesn't allow source blocks for other languages
- Have to add both org and literate-haskell markup for code blocks
** IDEA Use =X.L.Stoppable= to develop a power-savings mode
Maybe auto-enable it when battery is below a threshold.
** TODO =displayText='s message doesn't show up in some situations      :hard:
I investigated this for some time and couldn't figure out why this happens.
Granted, I did only test it in Xephyr.

From some experiments,
- both timed and forever versions work fine in whichkey
- neither work when used as part of =serverCommands=
- they work when used as part of a =spawn= call (=echo ... | dzen2 -p ...=)

The last one suggests that the std input is not being passed correctly.
Wrapping dzen in a shell script and calling that shows that this is indeed correct.
Not sure how to fix it though. The fact that they work in whichkey is really surprising.

** TODO Try to speed up message passing between client and server     :hard:
This is the cause of the ~1s taken for window switching from the status bar.
* Imports
Libraries for system IO actions
#+begin_src haskell
import System.IO (openFile)
import System.Posix.IO
import System.Posix.Types (CPid(..))
import System.Process (system, readProcess)
import System.Posix.Process (executeFile, getProcessID)
import System.Posix.Signals (signalProcess, sigKILL)
import Control.Concurrent (threadDelay)
import System.Environment (getArgs, getEnv)
import System.Exit (ExitCode(..))
import Control.Exception (try, displayException, SomeException)
import GHC.IO.Handle (hClose, hDuplicateTo)
import System.FilePath.Posix ((</>))
import System.Directory
import Data.Time
#+end_src

Some general libraries
#+begin_src haskell
import Relude as R
import Relude.Extra.Foldable1
import Relude.Extra.Tuple
import Relude.Extra.Bifunctor
import Relude.Extra.Map (lookup)
import qualified Relude.Unsafe as Unsafe
import qualified Prelude as P
import Data.Char
import qualified Data.Text as T
import qualified Data.Text.Lazy as TL
import Data.Function
#+end_src

Reverse application functions
#+begin_src haskell
import Flow
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad hiding (Color, whenJust)
import qualified XMonad.StackSet as W
#+end_src

Some utilities from =xmonad-contrib=
#+begin_src haskell
import XMonad.Util.Run
import XMonad.Layout.LayoutModifier (ModifiedLayout)
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Font (Align(..))
import XMonad.Actions.Submap (submap)
#+end_src

Change the cursor
#+begin_src haskell
import XMonad.Util.Cursor (setDefaultCursor, xC_left_ptr)
#+end_src

Easy formatting
#+begin_src haskell
import Text.Printf
import Data.Text.Format (Only(..))
import qualified Data.Text.Format as F
#+end_src

Some helpers for output and parsing
#+begin_src haskell
import XMonad.Config.Dmwit (outputOf)
#+end_src

Libraries for managing and logging to the status bar.
#+begin_src haskell
import XMonad.Hooks.DynamicLog (PP(..))
import XMonad.Hooks.DynamicBars
import XMonad.Hooks.ManageDocks (docks, avoidStruts, AvoidStruts)
#+end_src

Libraries for pretty-printing to the status bar
#+begin_src haskell
import XMonad.Util.WorkspaceCompare (getSortByIndex)
#+end_src

Library to listen for external messages
#+begin_src haskell
import XMonad.Hooks.ServerMode
#+end_src

X11 imports to send atoms to the server
#+begin_src haskell
import qualified Graphics.X11.Xlib as X11
import qualified Graphics.X11.Xlib.Extras as X11
#+end_src

Argument parsing library
#+begin_src haskell
import Options.Applicative
#+end_src

* Utils
Some utility functions to make life easy
#+begin_src haskell
-- markup & logging
wrap :: Text -> Text -> Text -> Text
wrap left right middle = left <> middle <> right

pad :: Text -> Text
pad = wrap " " " "

shorten :: Int -> Text -> Text
shorten maxlen text = case text `T.compareLength` maxlen of
  GT -> T.snoc (T.take maxlen text) ellipsis
  otherwise -> text
  where ellipsis = 'â€¦'

format fmt = TL.toStrict . F.format fmt
format1 str item = format str (Only item)

-- parsing
withInfo opts desc = info (helper <*> opts) $ progDesc desc

-- three-tuples
mapThd3 f (a,b,c) = (a,b, f c)
dropSnd3 (a,b,c) = (a,c)
dropThd3 (a,b,c) = (a,b)

-- timing
logDuration :: MonadIO m => m a -> m a
logDuration action = do
  startTime <- io getCurrentTime
  result <- action
  endTime <- io getCurrentTime
  putStrLn $ "Time taken: " ++ show (diffUTCTime endTime startTime)
  return result

-- reverse function application
infixl 0 |>>
x |>> f = x |> fmap f
#+end_src

XMonad installs =SIGCHLD= and =SIGPIPE= handlers which ignore these signals. This causes issues with some programs, like =stack build=.
#+begin_src haskell
withoutSignalHandlers :: X a -> X a
withoutSignalHandlers action = do
  uninstallSignalHandlers
  result <- action
  installSignalHandlers
  return result
#+end_src
* Markup(s)
Define interfaces for markup languages used later.

** Dzen
First, dzen for the =which-key= popups.
dzen has a lot more formatting options, like rectangles, xbm icons, and whatnot.
Might be interesting to explore later.
#+begin_src haskell
type Color = Text

dzenFg, dzenBg :: Color -> Text -> Text
dzenFg color string = format "^fg({}){}^fg()" (color, string)
dzenBg color string = format "^bg({}){}^bg()" (color, string)
#+end_src

** Lemonbar
Enumerate the mouse buttons. We'll use the =Enum= instance to use it in the markup, but
since the default =Enum= instance starts counting from 0 and we want to start from 1, we'll have to add 1 to it.
#+begin_src haskell
data MouseButton
  = LeftClick
  | MiddleClick
  | RightClick
  | ScrollUp
  | ScrollDown
  | DoubleLeftClick
  | DoubleMiddleClick
  | DoubleRightClick
  deriving (Eq, Ord, Show, Enum)

fromMouseButton :: MouseButton -> Int
fromMouseButton = succ . fromEnum
#+end_src

Then we define the formatting possibilities in lemonbar markup.
#+begin_src haskell
data LemonbarFormatting
  = Foreground Color
  | Background Color
  | Reverse
  | Underline Color
  | Overline Color
  | Font Int
  | Offset Int
  | Action MouseButton Text
  deriving (Eq, Show)
#+end_src

And finally convert these to markup using the [[https://github.com/LemonBoy/bar#formatting][lemonbar formatting spec]].
#+begin_src haskell
lemonbarFormatOne :: LemonbarFormatting -> Text -> Text
lemonbarFormatOne fmt = case fmt of
  (Foreground color)      -> wrap (bracket $ format1 "F{}" color) (bracket "F-")
  (Background color)      -> wrap (bracket $ format1 "B{}" color) (bracket "B-")
  (Reverse)               -> wrap (bracket "R") (bracket "R")
  (Underline color)       -> wrap (bracket (format1 "u{}" color) <> bracket "+u") (bracket "-u")
  (Overline color)        -> wrap (bracket (format1 "o{}" color) <> bracket "+o") (bracket "-o")
  (Font index)            -> wrap (bracket (format1 "T{}" index)) (bracket "T-")
  (Offset size)           -> (bracket (format1 "O{}" size) <>)
  (Action button command) -> wrap (bracket (format "A{}:{}:" (fromMouseButton button, command))) (bracket "A")
  where
    bracket = wrap "%{" "}"

lemonbarFormat :: [LemonbarFormatting] -> Text -> Text
lemonbarFormat fmts = foldr (.) id (lemonbarFormatOne <$> fmts)
#+end_src

* Colors
** one-dark
#+begin_src haskell
onedarkBlack  = "#282c34"
onedarkRed    = "#e06c75"
onedarkGreen  = "#98c379"
onedarkYellow = "#e5c07b"
onedarkBlue   = "#61afef"
onedarkPurple = "#c678dd"
onedarkCyan   = "#56b6c2"
onedarkGrey   = "#abb2bf"

onedarkGreenDarker = "#68a349"
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

The =NamedActions= module already provides some of this functionality, but it shows /all/ the keybindings at once.
=which-key='s approach to this is to only show keybindings which have partially been completed.

As an example, let this be your config:
#+begin_example
[ ("C-u f", "use foo")
, ("C-u m", "use moo")
, ("C-u x", "use xoo")
, ("C-u r", "use roo")

, ("C-g f", "goto foo")
, ("C-g m", "goto moo")
, ("C-g x", "goto xoo")
, ("C-g r", "goto roo")

, ("C-i f", "info foo")
, ("C-i m", "info moo")
, ("C-i x", "info xoo")
, ("C-i r", "info roo")
]
#+end_example

=NamedActions= would provide a help bindings (such as "F1") that you could hit to see all of these at once.
In contrast, this implementation of =which-key= does not provide a help binding, but you could hit ~C-i~ (say) and the help for keys which /complete/ C-i bindings would pop up after a delay (say, 2 seconds).
That would look like this:
#+begin_example
f -> info foo
m -> info moo
x -> info xoo
r -> info roo
#+end_example
I find this a lot better for discoverability, as seeing all bindings at once is a bit overwhelming.

We use =dzen= with some basic settings to display text on the screen. I would've liked to use =XMonad.Util.Dzen= for this,
but it only contains =X= actions, while we only have access to =IO= in some situations.
#+begin_src haskell
displayTextFont :: String
displayTextFont = "Iosevka:pixelsize=15"

displayTextSync :: MonadIO m => Maybe Int -> Text -> m ()
displayTextSync time text = io . void $ readProcess "dzen2"
  (("-p" : timeArg) ++
   [ "-l", show numLines
   , "-ta", "c" , "-sa", "c"
   , "-e", "onstart=uncollapse"                  -- show all lines at startup (by default they only show on mouse hover)
   , "-fn", displayTextFont
   ])
  (toString text)
  where
    numLines = max 0 (length (lines text) - 1)  -- we only count slave lines, so everything after the first one
    timeArg = maybeToList $ show <$> time

displayText time text = void $ xfork $ displayTextSync time text

displayTextSyncTill, displayTextTill :: MonadIO m => Int -> Text -> m ()
displayTextSyncTill = displayTextSync . Just
displayTextTill = displayText . Just

displayTextSyncForever, displayTextForever :: MonadIO m => Text -> m ()
displayTextSyncForever = displayTextSync Nothing
displayTextForever = displayText Nothing
#+end_src

We then need a pretty-printer for displaying the keybindings. The =NamedActions= module has functions for naming and printing keybindings, but unfortunately it's too restrictive and doesn't allow any customization. I realized that
I don't require much of that functionality, and the provided pretty-printer is kind of ugly.
Let's define our own the pretty-printer first.
I'm using =equalizeLeft= and =equalizeRight= since we're using center-aligning in =dzen=, so the lines need to be of equal length to match up.
#+begin_src haskell
data WhichkeyConfig
  = WhichkeyConfig
  { keyFg  :: Color     -- ^ foreground color for keys
  , descFg :: Color     -- ^ foreground color for action descriptions
  , delay  :: Rational  -- ^ delay (in seconds) after which whichkey pops up
  }

instance Default WhichkeyConfig where
  def = WhichkeyConfig
    { keyFg  = onedarkBlue
    , descFg = onedarkGreen
    , delay  = 1.5
    }

whichkeyShowBindings :: WhichkeyConfig -> [(Text, Text, X ())] -> [Text]
whichkeyShowBindings WhichkeyConfig{keyFg, descFg} keybinds =
  keybinds
  |>> dropThd3
  |>> first capitalizeIfShift
  |> unzip
  |> bimap equalizeLeft equalizeRight
  |> uncurry zip
  |>> bimap (dzenFg keyFg) (dzenFg descFg)
  |>> format "{} -> {}"
  where
    capitalizeIfShift keystr
      | "S-" `T.isPrefixOf` last3 = T.snoc (T.dropEnd 3 keystr) (toUpper lastChar)
      | otherwise = keystr
      where
        last3 = T.takeEnd 3 keystr
        lastChar = T.last last3

    equalizeLeft keys =
      let maxLen = maximum1 (T.length <$> T.empty :| keys) in
      T.justifyRight maxLen ' ' <$> keys

    equalizeRight descriptions =
      let maxLen = maximum1 (T.length <$> T.empty :| descriptions) in
      T.justifyLeft maxLen ' ' <$> descriptions
#+end_src

Like emacs' =which-key=, the help message should activate after a delay and close by itself if any key is pressed.
Let's define a custom submap function for that. For the reasons stated above, I'm using simple strings instead of the =NamedActions= module here.
See [[opening-apps]] for a usage example.
*NOTE*: this might cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue, since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: (LayoutClass l Window, Read (l Window))
               => WhichkeyConfig
               -> XConfig l
               -> [(Text, Text, X ())]
               -> X ()
whichkeySubmap whichkeyConf config keybinds = do
  pid <- xfork (threadDelay (seconds $ delay whichkeyConf) >> displayTextSyncForever (toHelp keybinds))
  catchX (submap . mkKeymap config $ first toString . dropSnd3 <$> keybinds) mempty
  io $ signalProcess sigKILL pid
  spawn "pkill dzen2"
  where
    toHelp = unlines . whichkeyShowBindings whichkeyConf
#+end_src

* Client-Server
Using =X.H.ServerMode= allows us to control XMonad externally.
This allows for executing commands from the status bar, external prompts like =albert= etc.

=ServerMode='s actions are of the type =X ()=. This prevents them from taking any input, which reduces its usability (eg. for switching workspaces, the workspace name needs to be taken as input).
There's two ways to solve this:
1. Create a different listener for each command that needs an input.
2. Take the first word as the name of the command and the rest as arguments.

The second solution has an implicit failure state (when the input string is empty), but probably much less wasteful. This is the one that's used here. We enforce that the string is not empty through the command-line parser.

** Client
We first write the client which can send commands to the server.

The server listens for particular "addresses" that we can send arguments to.
We represent this with a simple datatype.
#+begin_src haskell
data Command = Command { addr :: String, command_ :: String, input :: [String] }
#+end_src

This code is modified from the documentation of =ServerMode=.
I don't understand all of this, but it should /Just Work(TM)/
#+begin_src haskell
sendCommand :: Command -> IO ()
sendCommand Command{addr, command_, input} = do
  let joinedInput = P.unwords (command_:input)
  display <- X11.openDisplay ""
  rootWin <- X11.rootWindow display $ X11.defaultScreen display
  addrAtom <- X11.internAtom display addr False
  msgAtom <- X11.internAtom display joinedInput False
  X11.allocaXEvent $ \event -> do
                  X11.setEventType event X11.clientMessage
                  X11.setClientMessageEvent event rootWin addrAtom 32 msgAtom X11.currentTime
                  X11.sendEvent display rootWin False X11.structureNotifyMask event
                  X11.sync display False
#+end_src
** Server
#+PROPERTY: header-args :tangle "Main.hs"

We define a list of commands that can be called.
For now we'll just define a command to switch to the appropriate workspace for use in the status bar.
#+begin_src haskell
serverCommands :: XConfig l -> [(String, String -> X ())]
serverCommands config =
  [ ("switch", cursorSwitchWorkspace)
  ]
#+end_src

=ServerMode= defaults this address to ="XMONAD_COMMAND"=. Since we're using the second method,
there's no real reason to change this or use multiple addresses.
#+begin_src haskell
serverAddress :: String
serverAddress = "XMONAD_COMMAND"
#+end_src

Then we need to define a function to split the input and lookup the appropriate action to take.
#+begin_src haskell
serverCallCommand :: Map String (String -> X ()) -> String -> X ()
serverCallCommand commandMap input =
  case lookup command commandMap of
    Just action -> action input'
    Nothing     -> io $ hPutStrLn stderr $ printf "Command '%s' not found" command
  where
    (command, input') = second (drop 1) $ break (== ' ') input
#+end_src

Finally, we set up the listener.
#+begin_src haskell
serverListenerHook :: XConfig l -> Event -> X All
serverListenerHook config =
  let commands = fromList (serverCommands config) in
  serverModeEventHookF serverAddress (serverCallCommand commands)
#+end_src

For convenience, we provide a command to add this functionality to a config.
#+begin_src haskell
serverEnable :: XConfig l -> XConfig l
serverEnable config@XConfig{handleEventHook} = config
  { handleEventHook = handleEventHook <+> serverListenerHook config }
#+end_src

*** Switch workspaces
While the staple =StackSet.view= and =StackSet.greedyView= work well enough for the server's ="switch"= action, it has some unintuitive behaviour in case of multiple monitors.
Imagine there are two monitors and you click the workspace button on the status bar on the unfocused monitor -
this would activate the workspace on the active monitor, which is not the desired behaviour.
If the workspace you click on is the one that's focused on the foucsed monitor, then you probably want that
workspace to be focused on this monitor.
In both cases, the monitor the cursor is on is the one that's expected to be focused, so we should do this first.
Then, as seen in the second case, we should always put the selected workspace on this monitor, so we should use =greedyView= rather than =view=.

Accordingly, first, an action to focus the workspace the cursor is on.
#+begin_src haskell
focusCursor :: X ()
focusCursor = void $ runMaybeT $ do
  pos <- MaybeT $ reader mousePosition
  workspace <- W.tag . W.workspace <$> MaybeT (uncurry pointScreen pos)
  lift $ windows $ W.view workspace
#+end_src

Then view the selected workspace on this monitor.
#+begin_src haskell
cursorSwitchWorkspace :: WorkspaceId -> X ()
cursorSwitchWorkspace workspace = do
  focusCursor
  windows $ W.greedyView workspace
#+end_src

* Polybar
[[https://github.com/polybar/polybar][Polybar]] is pretty cool. It has a lot of efficient modules for most things and is quite customizable.
Aside from the actual choice of bar, there are things I want from a status bar:
1. Show workspaces, Layout, extras etc. with nice highlighting
2. Workspace indicators on the bar should focus that workspace on being clicked
3. Different highlighting for bars on unfocused monitors
4. On adding or removing a monitor, bars should be added or deleted automatically

The first of these requirements is pretty standard, and can be achieved using some =lemonbar= markup that Polybar uses.

The second can be achieved with =xdotool set_desktop <workspace>=. This requires EWMH compliance which can be achieved with =X.H.EwmhDesktops=.
The other option is to use =X.H.ServerMode= which allows us to call arbitrary actions from the bar, like changing the layout.
This is slightly more complicated, but should be worth it for the extensibility. This is the option used here.
A major downside of this approach is that it is slow - taking up to a second sometimes. Some logging reveals that the message passing is the bottleneck, and there isn't much that can be done about that. Switching to the =xdotool= approach is thus quite attractive, but has the downside that the action that can be taken is much simpler (equivalent to a =StackSet.view=) and somewhat unintuitive. Since I don't use this too much, I'll let this be for now.

The third and fourth can be achieved with =X.H.DynamicBars=.

** Workspace switch buttons
Since polybar can be formatted to call scripts on click, we need to write a function which messages the
server to switch to the workspace clicked on and include it in our pretty printer.
This function needs to be the first to run on the workspace name, since it needs access to the unaltered
name to switch to it. It should also pad the name so that it's easy to click.
#+begin_src haskell
workspaceSwitcher :: WorkspaceIdT -> Text
workspaceSwitcher workspace =
  lemonbarFormat [Action LeftClick switchCommand] . pad $ workspace
  where
    switchCommand = format1 "bin/launch client switch '{}'" workspace
#+end_src

Since it needs to be applied in a bunch of places, we create a function to transform a pretty-printer to use it.
#+begin_src haskell
workspaceSwitcheroo :: PPText -> PPText
workspaceSwitcheroo ppt@PPText{..} = ppt
  { pptCurrent = pptCurrent . workspaceSwitcher
  , pptVisible = pptVisible . workspaceSwitcher
  , pptHidden = pptHidden . workspaceSwitcher
  , pptHiddenNoWindows = pptHiddenNoWindows . workspaceSwitcher
  , pptVisibleNoWindows = fmap (. workspaceSwitcher) pptVisibleNoWindows
  }
#+end_src

** Pretty-printing
First, some code to switch between text and string
#+begin_src haskell
type WorkspaceIdT = Text

data PPText = PPText
  { pptCurrent :: WorkspaceIdT -> Text
  , pptVisible :: WorkspaceIdT -> Text
  , pptHidden  :: WorkspaceIdT -> Text
  , pptHiddenNoWindows :: WorkspaceIdT -> Text
  , pptVisibleNoWindows :: Maybe (WorkspaceIdT -> Text)
  , pptUrgent :: WorkspaceIdT -> Text
  , pptSep :: Text
  , pptWsSep :: Text
  , pptTitle :: Text -> Text
  , pptTitleSanitize :: Text -> Text
  , pptLayout :: Text -> Text
  , pptOrder :: [String] -> [String]
  , pptSort :: X ([WindowSpace] -> [WindowSpace])
  , pptExtras :: [X (Maybe Text)]
  , pptOutput :: Text -> IO ()
  }

ppTextToString :: PPText -> PP
ppTextToString ppt = PP
  { ppCurrent = convert $ pptCurrent ppt
  , ppVisible = convert $ pptVisible ppt
  , ppHidden  = convert $ pptHidden ppt
  , ppHiddenNoWindows = convert $ pptHiddenNoWindows ppt
  , ppVisibleNoWindows = convert <$> pptVisibleNoWindows ppt
  , ppUrgent = convert $ pptUrgent ppt
  , ppSep = toString $ pptSep ppt
  , ppWsSep = toString $ pptWsSep ppt
  , ppTitle = convert $ pptTitle ppt
  , ppTitleSanitize = convert $ pptTitleSanitize ppt
  , ppLayout = convert $ pptLayout ppt
  , ppOrder = pptOrder ppt
  , ppSort = pptSort ppt
  , ppExtras = (fmap . fmap . fmap) toString $ pptExtras ppt
  , ppOutput = pptOutput ppt . toText
  }
  where convert f = toString . f . toText

ppStringToText :: PP -> PPText
ppStringToText pp = PPText
  { pptCurrent = convert $ ppCurrent pp
  , pptVisible = convert $ ppVisible pp
  , pptHidden  = convert $ ppHidden pp
  , pptHiddenNoWindows = convert $ ppHiddenNoWindows pp
  , pptVisibleNoWindows = convert <$> ppVisibleNoWindows pp
  , pptUrgent = convert $ ppUrgent pp
  , pptSep = toText $ ppSep pp
  , pptWsSep = toText $ ppWsSep pp
  , pptTitle = convert $ ppTitle pp
  , pptTitleSanitize = convert $ ppTitleSanitize pp
  , pptLayout = convert $ ppLayout pp
  , pptOrder = ppOrder pp
  , pptSort = ppSort pp
  , pptExtras = (fmap . fmap . fmap) toText $ ppExtras pp
  , pptOutput = ppOutput pp . toString
  }
  where convert f = toText . f . toString


instance Default PPText where
  def = ppStringToText def
#+end_src

The basic pretty-printer which the upcoming ones should override.
#+begin_src haskell
basicPP :: PPText
basicPP = def
  { pptSep = "  "
  , pptWsSep = " "
  , pptTitleSanitize = T.filter (`notElem` ['%','{','}'])
  , pptOrder = layoutFirstOrder
  , pptSort = getSortByIndex
  , pptExtras = []
  , pptOutput = const mempty
  }
  where
    layoutFirstOrder (workspaces : layout : title : extras) =
      [layout] ++ extras ++ [workspaces, title]
    layoutFirstOrder other = other
#+end_src

This is the one that finally gets applied.
#+begin_src haskell
chosenPP :: (PPText, PPText)
chosenPP = (onedarkFocusedPP, onedarkUnfocusedPP)
         |> bimapBoth workspaceSwitcheroo
#+end_src

*** one-dark
#+begin_src haskell
onedarkFocusedPP :: PPText
onedarkFocusedPP = basicPP
  { pptCurrent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkGreen, Underline onedarkGreenDarker ]
  , pptVisible = lemonbarFormat [ Foreground onedarkGreen, Background onedarkGrey, Underline onedarkGreen ]
  , pptVisibleNoWindows = Just $ lemonbarFormat [ Foreground onedarkBlack, Background onedarkGrey, Underline onedarkGreen ]
  , pptHidden = lemonbarFormat [ Foreground onedarkGreen, Underline onedarkGreen ]
  , pptHiddenNoWindows = lemonbarFormat [ Foreground onedarkGrey ]
  , pptUrgent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkRed ]
  , pptTitle = lemonbarFormat [ Foreground onedarkGrey ] . shorten 50
  , pptLayout = lemonbarFormat [ Foreground onedarkYellow ]
  }

onedarkUnfocusedPP :: PPText
onedarkUnfocusedPP = onedarkFocusedPP
  { pptCurrent = Unsafe.fromJust $ pptVisibleNoWindows onedarkFocusedPP
  , pptVisible = pptHiddenNoWindows onedarkFocusedPP
  , pptVisibleNoWindows = Just $ pptHiddenNoWindows onedarkFocusedPP
  , pptHidden = pptHiddenNoWindows onedarkFocusedPP
  }
#+end_src

** Dynamic bar highlighting and management
=DynamicBars= asks for a bar startup function of the type =ScreenId -> IO Handle=, where =ScreenId= is simply a newtype for =Int=.
On the other hand, Polybar requires an xrandr monitor name to know which screen to use. So first we need a mapping between the two.
I simply use =xrandr= to query which monitors are active and hope to dear god that they are in the same order as the =ScreenId='s.
So far I have not been let down.
#+begin_src haskell
monitorIds :: IO [(ScreenId, Text)]
monitorIds = do
  output <- toText <$> outputOf "xrandr --listactivemonitors 2>/dev/null | awk '{print $1 $4}'"
  return $ mapMaybe parseMonitor . drop 1 $ lines output
  where
    parseMonitor :: Text -> Maybe (ScreenId, Text)
    parseMonitor text = do
      let (idText, monitorText) = T.breakOn ":" text
      monitor <- T.stripPrefix ":" monitorText
      id <- readMaybe . toString $ idText
      return (S id, monitor)
#+end_src

We want to use =spawnPipe= to start polybar and pass input to its stdin, but unfortunately polybar doesn't read from there.
So we need to use an intermediary to pass it into polybar through a named pipe. We /could/ do this from xmonad itself, but then
we have to maintain consistency between xmonad and polybar about the name of the pipe. That, and using named pipes in haskell
turns out to have a lot of gotchas. We do this through a shell script =polybar-start-monitor.sh=

The relevant polybar module just reads a the passed environment variable =STDINFIFO=
#+begin_src conf :tangle no
[module/stdin]
type = custom/script
tail = true
exec = cat $STDINFIFO
#+end_src

And finally the startup and cleanup functions for the bar.
#+begin_src haskell
polybarStartup :: ScreenId -> IO Handle
polybarStartup screenId = do
  monitors <- monitorIds
  case P.lookup screenId monitors of
    Just monitor -> spawnPipe . toString $ format1 "bin/polybar-start-monitor.sh {}" monitor
    Nothing -> error $ format "No monitor found for {} in {}" (P.show screenId, P.show monitors)

polybarCleanup :: IO ()
polybarCleanup = do
  (CPid pid) <- getProcessID
  spawn $ printf "pkill --parent %d bin/polybar-start-monitor.sh" pid
#+end_src

And then plumb everything together with =DynamicBars= and =ManageDocks= (to actually make space for the bar).
#+begin_src haskell
polybarEnable :: LayoutClass l Window
              => XConfig l
              -> XConfig (ModifiedLayout AvoidStruts l)
polybarEnable config@XConfig{..}  = docks $ config
  { startupHook     = startupHook      <+> dynStatusBarStartup polybarStartup polybarCleanup
  , handleEventHook = handleEventHook  <+> dynStatusBarEventHook polybarStartup polybarCleanup
  , logHook         = logHook          <+> multiPP focusedPP unfocusedPP
  , layoutHook      = avoidStruts $ layoutHook
  }
  where (focusedPP, unfocusedPP) = bimapBoth ppTextToString chosenPP
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , keys            = myKeymap
  , mouseBindings   = myMouseBindings
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

setTestModMask config = config { modMask = testModMask }
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys

myKeys :: [(String, X ())]
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  , infoKeys
  ]
#+end_src

Some quick helper functions
#+begin_src haskell
spawnKeymap :: Text -> [(Text, Text, String)] -> (String, X ())
spawnKeymap key items = (toString key, whichkeySubmap def myConfig $ mapThd3 spawn <$> items)
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~, but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = return $ spawnKeymap "M-u" apps
  where
    apps = [ ("t"  , "Terminal"    , terminal myConfig)
           , ("e"  , "Emacs Client", "emacsclient -c")
           , ("S-e", "Emacs"       , "emacs")
           , ("f"  , "Firefox"     , "firefox")
           , ("r"  , "Ranger"      , "$TERMINAL ranger")
           , ("w"  , "WhatsApp"    , "whatsapp.sh")
           ]
#+end_src

*** Info keys
Keys for referring to information quickly - latex symbols, nerdfont icons etc.
#+begin_src haskell
infoKeys = return $ spawnKeymap "M-i" info
  where
    info = [ ("n"  , "Nerdfont reference"      , "nerdfont-dmenu.sh")
           , ("l"  , "LaTeX symbol reference"  , "xdg-open http://detexify.kirelabs.org/classify.html")
           , ("x m", "xmonad reference"        , "xdg-open https://hackage.haskell.org/package/xmonad")
           , ("x c", "xmonad-contrib reference", "xdg-open https://hackage.haskell.org/package/xmonad-contrib")
           ]
#+end_src

** Mouse bindings
Let's keep this empty for now. The default behaviour of making windows floating when dragged around is really irritating.
#+begin_src haskell
myMouseBindings :: XConfig Layout -> Map (ButtonMask, Button) (Window -> X ())
myMouseBindings config = fromList []
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
The default cursor is also... not the best - change it to something more standard.
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
    setDefaultCursor xC_left_ptr
#+end_src

* Running
** Restarting
=restartConfig= copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
Using =SomeException= catches all exceptions
#+begin_src haskell
buildConfig :: X Bool
buildConfig =
  withoutSignalHandlers
    (io (try (system "bin/build") :: IO (Either SomeException ExitCode)))
    >>= \case
      Right ExitSuccess -> return True
      otherwise -> return False

restartConfig :: Bool -> X ()
restartConfig resume = do
  whenX buildConfig $ do
    broadcastMessage ReleaseResources
    io . flush =<< asks display
    when resume writeStateToFile
    origArgs <- io getArgs
    catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Logging
There's two ways to view xmonad logs. Either you set =exec <xmonad executable>= in your =.xinitrc= and redirect the logs of your X session with =startx &> <logfile>=.
The other, cleaner way, is to tell hardcode the path in =xmonad= itself. This way you're free to start your session however and not capture /all/ the logs.

This [[https://www.reddit.com/r/xmonad/comments/cr0ry3/viewing_stderr_from_stack_config/exkkmie/][code]] accomplishes this, courtesy of [[https://www.reddit.com/user/simonfxr/][u/simonfixr]].
#+begin_src haskell
redirectStdHandles :: FilePath -> IO ()
redirectStdHandles directory = do
  createDirectoryIfMissing True directory
  hClose stdout
  hClose stderr
  stdout' <- openFile (directory </> "xmonad-stdout.log") WriteMode
  stderr' <- openFile (directory </> "xmonad-stderr.log") WriteMode
  hDuplicateTo stdout' stdout
  hDuplicateTo stderr' stderr

redirectLogs :: FilePath -> XConfig l -> XConfig l
redirectLogs directory conf@XConfig{startupHook} =
  conf { startupHook = io (redirectStdHandles directory) >> startupHook }
#+end_src

** Argument parsing
We need to handle arguments to disambiguate between three cases:
1. Main: running XMonad as a WM (and a server)
2. Test: running XMonad in a test environment
3. Client: running as a client to send a message to the XMonad server

We represent this as an ADT.
#+begin_src haskell
data Executable = XMonad { testing :: Bool } | Client Command
#+end_src

The XMonad parser is quite simple.
#+begin_src haskell
xmonadParser :: Parser Executable
xmonadParser = XMonad
  <$> switch (long "test" <> help "Run XMonad in a test environment" )
#+end_src

The client parser is a bit more involved
#+begin_src haskell
clientParser :: Parser Executable
clientParser = Client <$> commandParser

commandParser :: Parser Command
commandParser = Command
                <$> strOption
                      (help "Target address for the command"
                       <> short 'a'
                       <> long "addr"
                       <> metavar "ADDR"
                       <> value serverAddress
                       <> showDefault)
                <*> strArgument
                      (help "The command to call"
                       <> metavar "COMMAND")
                <*> many
                      (strArgument
                        (help "Arguments for the command"
                         <> metavar "ARGS"))
#+end_src

Finally we separate these two.
#+begin_src haskell
mainParser :: Parser Executable
mainParser = subparser $ mconcat
  [ command "start"  (xmonadParser `withInfo` "Start XMonad")
  , command "client" (clientParser `withInfo` "Send a message to the XMonad server")
  ]

parseArguments :: IO Executable
parseArguments = execParser (mainParser `withInfo` "Interact with XMonad")
#+end_src

** Main
We define the interpreters for each possible usage.
#+begin_src haskell
runXMonad config
    = launch
    $ polybarEnable
    $ serverEnable
    $ config

runExecutable :: Executable -> IO ()
runExecutable (XMonad { testing = False })
    = runXMonad
    $ redirectLogs "/tmp"
    $ myConfig

runExecutable (XMonad { testing = True })
    = runXMonad
    $ setTestModMask
    $ myConfig

runExecutable (Client command)
    = sendCommand command
#+end_src

Finally, we run the parser and interpret the result.
#+begin_src haskell
main :: IO ()
main = parseArguments >>= runExecutable
#+end_src
