#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"
#+TODO: TODO IDEA | DONE

* Ideas & Fixes
** IDEA Workspace-aware browser launcher
Credit: [[https://github.com/altercation/dotfiles-tilingwm/blob/31e23a75eebdedbc4336e7826800586617d7d27d/.xmonad/xmonad.hs#L406][Ethan Schoonover]]
I could configure the browser launcher to select particular profiles or tabs to start with - based on the workspace.
Since most of my workspaces are generic, using workspace names to decide might be a good idea.
This could be a significant gain.

#+begin_example
workspace name = "grading" --> tabs: <gradescope> <gmail/.jobs>
workspace name = "config" --> tabs: <xmonad> ...
#+end_example

** TODO Translate some keys to Firefox shortcuts when it is open
I've used this in a previous setup, and it works amazingly well.
** IDEA Convert this to a literate haskell file while maintaining org syntax
Pros:
- Provides editor support for haskell --> this is a /huge/ benefit
- Can split up files, if required
- No tangling required

Cons:
- Possibly removes editor support for org-mode
- Doesn't allow source blocks for other languages
- Have to add both org and literate-haskell markup for code blocks
** IDEA Use =X.L.Stoppable= to develop a power-savings mode
Maybe auto-enable it when battery is below a threshold.
** TODO =restartConfig='s displays a blank dzen when build fails

* Imports
Libraries for system IO actions
#+begin_src haskell
import System.IO (openFile)
import System.Posix.IO
import System.Posix.Types (CPid(..))
import System.Process (system, readProcess)
import System.Posix.Process (executeFile, getProcessID)
import System.Posix.Signals (signalProcess, sigKILL)
import Control.Concurrent (threadDelay)
import System.Environment (getArgs, getEnv)
import System.Exit (ExitCode(..))
import Control.Exception (try, displayException, SomeException)
import GHC.IO.Handle (hClose, hDuplicateTo)
import System.FilePath.Posix ((</>))
import System.Directory
#+end_src

Some general libraries
#+begin_src haskell
import Relude as R
import Relude.Extra.Foldable1
import Relude.Extra.Tuple
import Relude.Extra.Bifunctor
import qualified Relude.Unsafe as Unsafe
import qualified Prelude as P
import Data.Char
import qualified Data.Text as T
import qualified Data.Text.Lazy as TL
import Data.Function
#+end_src

Reverse application functions
#+begin_src haskell
import Flow
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad hiding (Color)
#+end_src

Some utilities from =xmonad-contrib=
#+begin_src haskell
import XMonad.Util.Run
import XMonad.Layout.LayoutModifier (ModifiedLayout)
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

Libraries for =which-key= emulation
#+begin_src haskell
import XMonad.Util.Font (Align(..))
import XMonad.Actions.Submap (submap)
#+end_src

Change the cursor
#+begin_src haskell
import XMonad.Util.Cursor (setDefaultCursor, xC_left_ptr)
#+end_src

Easy formatting
#+begin_src haskell
import Text.Printf
import Data.Text.Format (Only(..))
import qualified Data.Text.Format as F
#+end_src

Some helpers for output and parsing
#+begin_src haskell
import XMonad.Config.Dmwit (outputOf)
import Text.Read
#+end_src

Libraries for managing and logging to the status bar.
#+begin_src haskell
import XMonad.Hooks.DynamicLog (PP(..))
import XMonad.Hooks.DynamicBars
import XMonad.Hooks.ManageDocks (docks, avoidStruts, AvoidStruts)
#+end_src

Libraries for pretty-printing to the status bar
#+begin_src haskell
import XMonad.Util.WorkspaceCompare (getSortByIndex)
#+end_src

* Utils
Some utility functions to make life easy
#+begin_src haskell
-- markup & logging
wrap :: Text -> Text -> Text -> Text
wrap left right middle = left <> middle <> right

pad :: Text -> Text
pad = wrap " " " "

shorten :: Int -> Text -> Text
shorten maxlen text = T.snoc (T.take maxlen text) ellipsis
  where ellipsis = 'â€¦'

format fmt = TL.toStrict . F.format fmt
format1 str item = format str (Only item)

-- three-tuples
mapThd3 f (a,b,c) = (a,b, f c)
dropSnd3 (a,b,c) = (a,c)
dropThd3 (a,b,c) = (a,b)

-- reverse function application
infixl 0 |>>
x |>> f = x |> fmap f
#+end_src
* Markup(s)
Define interfaces for markup languages used later.

** Dzen
First, dzen for the =which-key= popups.
dzen has a lot more formatting options, like rectangles, xbm icons, and whatnot.
Might be interesting to explore later.
#+begin_src haskell
type Color = Text

dzenFg, dzenBg :: Color -> Text -> Text
dzenFg color string = format "^fg({}){}^fg()" (color, string)
dzenBg color string = format "^bg({}){}^bg()" (color, string)
#+end_src

** Lemonbar
Enumerate the mouse buttons. We'll use the =Enum= instance to use it in the markup, but
since the default =Enum= instance starts counting from 0 and we want to start from 1, we'll have to add 1 to it.
#+begin_src haskell
data MouseButton
  = LeftClick
  | MiddleClick
  | RightClick
  | ScrollUp
  | ScrollDown
  | DoubleLeftClick
  | DoubleMiddleClick
  | DoubleRightClick
  deriving (Eq, Ord, Show, Enum)

fromMouseButton :: MouseButton -> Int
fromMouseButton = succ . fromEnum
#+end_src

Then we define the formatting possibilities in lemonbar markup.
#+begin_src haskell
data LemonbarFormatting
  = Foreground Color
  | Background Color
  | Reverse
  | Underline Color
  | Overline Color
  | Font Int
  | Offset Int
  | Action MouseButton Text
  deriving (Eq, Show)
#+end_src

And finally convert these to markup using the [[https://github.com/LemonBoy/bar#formatting][lemonbar formatting spec]].
#+begin_src haskell
lemonbarFormatOne :: LemonbarFormatting -> Text -> Text
lemonbarFormatOne fmt = case fmt of
  (Foreground color)      -> wrap (bracket $ format1 "F{}" color) (bracket "F-")
  (Background color)      -> wrap (bracket $ format1 "B{}" color) (bracket "B-")
  (Reverse)               -> wrap (bracket "R") (bracket "R")
  (Underline color)       -> wrap (bracket (format1 "u{}" color) <> bracket "+u") (bracket "-u")
  (Overline color)        -> wrap (bracket (format1 "o{}" color) <> bracket "+o") (bracket "-o")
  (Font index)            -> wrap (bracket (format1 "T{}" index)) (bracket "T-")
  (Offset size)           -> (bracket (format1 "O{}" size) <>)
  (Action button command) -> wrap (bracket (format "A{}:{}:" (fromMouseButton button, command))) (bracket "A")
  where
    bracket = wrap "%{" "}"

lemonbarFormat :: [LemonbarFormatting] -> Text -> Text
lemonbarFormat fmts = foldr (.) id (lemonbarFormatOne <$> fmts)
#+end_src

* Colors
** one-dark
#+begin_src haskell
onedarkBlack  = "#282c34"
onedarkRed    = "#e06c75"
onedarkGreen  = "#98c379"
onedarkYellow = "#e5c07b"
onedarkBlue   = "#61afef"
onedarkPurple = "#c678dd"
onedarkCyan   = "#56b6c2"
onedarkGrey   = "#abb2bf"

onedarkGreenDarker = "#68a349"
#+end_src

* Which-key
The emacs =which-key= package is a great discovery tool. This is a feeble attempt at emulating it.

The =NamedActions= module already provides some of this functionality, but it shows /all/ the keybindings at once.
=which-key='s approach to this is to only show keybindings which have partially been completed.

As an example, let this be your config:
#+begin_example
[ ("C-u f", "use foo")
, ("C-u m", "use moo")
, ("C-u x", "use xoo")
, ("C-u r", "use roo")

, ("C-g f", "goto foo")
, ("C-g m", "goto moo")
, ("C-g x", "goto xoo")
, ("C-g r", "goto roo")

, ("C-i f", "info foo")
, ("C-i m", "info moo")
, ("C-i x", "info xoo")
, ("C-i r", "info roo")
]
#+end_example

=NamedActions= would provide a help bindings (such as "F1") that you could hit to see all of these at once.
In contrast, this implementation of =which-key= does not provide a help binding, but you could hit ~C-i~ (say) and the help for keys which /complete/ C-i bindings would pop up after a delay (say, 2 seconds).
That would look like this:
#+begin_example
f -> info foo
m -> info moo
x -> info xoo
r -> info roo
#+end_example
I find this a lot better for discoverability, as seeing all bindings at once is a bit overwhelming.

We use =dzen= with some basic settings to display text on the screen. I would've liked to use =XMonad.Util.Dzen= for this,
but it only contains =X= actions, while we only have access to =IO= in some situations.
#+begin_src haskell
displayTextFont = "Iosevka:pixelsize=15"

displayTextSync :: MonadIO m => Maybe Rational -> Text -> m ()
displayTextSync time text = io . void $ readProcess "dzen2"
  (("-p" : timeArg) ++
   [ "-l", show numLines
   , "-ta", "c" , "-sa", "c"
   , "-e", "onstart=uncollapse"                  -- show all lines at startup (by default they only show on mouse hover)
   , "-fn", displayTextFont
   ])
  (toString text)
  where
    numLines = max 0 (length (lines text) - 1)  -- we only count slave lines, so everything after the first one
    timeArg = maybeToList $ show . seconds <$> time

displayText time text = void $ xfork $ displayTextSync time text

displayTextSyncTill, displayTextTill :: MonadIO m => Rational -> Text -> m ()
displayTextSyncTill = displayTextSync . Just
displayTextTill = displayText . Just

displayTextSyncForever, displayTextForever :: MonadIO m => Text -> m ()
displayTextSyncForever = displayTextSync Nothing
displayTextForever = displayText Nothing
#+end_src

We then need a pretty-printer for displaying the keybindings. The =NamedActions= module has functions for naming and printing keybindings, but unfortunately it's too restrictive and doesn't allow any customization. I realized that
I don't require much of that functionality, and the provided pretty-printer is kind of ugly.
Let's define our own the pretty-printer first.
I'm using =equalizeLeft= and =equalizeRight= since we're using center-aligning in =dzen=, so the lines need to be of equal length to match up.
#+begin_src haskell
data WhichkeyConfig
  = WhichkeyConfig
  { keyFg  :: Color     -- ^ foreground color for keys
  , descFg :: Color     -- ^ foreground color for action descriptions
  , delay  :: Rational  -- ^ delay (in seconds) after which whichkey pops up
  }

instance Default WhichkeyConfig where
  def = WhichkeyConfig
    { keyFg  = onedarkBlue
    , descFg = onedarkGreen
    , delay  = 1.5
    }

whichkeyShowBindings :: WhichkeyConfig -> [(Text, Text, X ())] -> [Text]
whichkeyShowBindings WhichkeyConfig{keyFg, descFg} keybinds =
  keybinds
  |>> dropThd3
  |>> first capitalizeIfShift
  |> unzip
  |> bimap equalizeLeft equalizeRight
  |> uncurry zip
  |>> bimap (dzenFg keyFg) (dzenFg descFg)
  |>> format "{} -> {}"
  where
    capitalizeIfShift keystr
      | "S-" `T.isPrefixOf` last3 = T.snoc (T.dropEnd 3 keystr) (toUpper lastChar)
      | otherwise = keystr
      where
        last3 = T.takeEnd 3 keystr
        lastChar = T.last last3

    equalizeLeft keys =
      let maxLen = maximum1 (T.length <$> T.empty :| keys) in
      T.justifyRight maxLen ' ' <$> keys

    equalizeRight descriptions =
      let maxLen = maximum1 (T.length <$> T.empty :| descriptions) in
      T.justifyLeft maxLen ' ' <$> descriptions
#+end_src

Like emacs' =which-key=, the help message should activate after a delay and close by itself if any key is pressed.
Let's define a custom submap function for that. For the reasons stated above, I'm using simple strings instead of the =NamedActions= module here.
See [[opening-apps]] for a usage example.
*NOTE*: this might cause issues with the variable mod-key I have going on. Hopefully this won't be /too/ much of an issue, since these submaps typically won't use the mod key.
#+begin_src haskell
whichkeySubmap :: (LayoutClass l Window, Read (l Window))
               => WhichkeyConfig
               -> XConfig l
               -> [(Text, Text, X ())]
               -> X ()
whichkeySubmap whichkeyConf config keybinds = do
  pid <- xfork (threadDelay (seconds $ delay whichkeyConf) >> displayTextSyncForever (toHelp keybinds))
  catchX (submap . mkKeymap config $ first toString . dropSnd3 <$> keybinds) mempty
  io $ signalProcess sigKILL pid
  spawn "pkill dzen2"
  where
    toHelp = unlines . whichkeyShowBindings whichkeyConf
#+end_src

* Polybar
[[https://github.com/polybar/polybar][Polybar]] is pretty cool. It has a lot of efficient modules for most things and is quite customizable.
Aside from the actual choice of bar, there are things I want from a status bar:
1. Show workspaces, Layout, extras etc. with nice highlighting
2. Workspace indicators on the bar should focus that workspace on being clicked
3. Different highlighting for bars on unfocused monitors
4. On adding or removing a monitor, bars should be added or deleted automatically

The first of these requirements is pretty standard, and can be achieved using some =lemonbar= markup that Polybar uses.
The second can be achieved with =xdotool set_desktop <workspace>=. This requires EWMH compliance which can be achieved with =X.H.EwmhDesktops=.
The third and fourth can be achieved with =X.H.DynamicBars=.

** Pretty-printing
First, some code to switch between text and string
#+begin_src haskell
type WorkspaceIdT = Text

data PPText = PPText
  { pptCurrent :: WorkspaceIdT -> Text
  , pptVisible :: WorkspaceIdT -> Text
  , pptHidden  :: WorkspaceIdT -> Text
  , pptHiddenNoWindows :: WorkspaceIdT -> Text
  , pptVisibleNoWindows :: Maybe (WorkspaceIdT -> Text)
  , pptUrgent :: WorkspaceIdT -> Text
  , pptSep :: Text
  , pptWsSep :: Text
  , pptTitle :: Text -> Text
  , pptTitleSanitize :: Text -> Text
  , pptLayout :: Text -> Text
  , pptOrder :: [String] -> [String]
  , pptSort :: X ([WindowSpace] -> [WindowSpace])
  , pptExtras :: [X (Maybe Text)]
  , pptOutput :: Text -> IO ()
  }

ppTextToString :: PPText -> PP
ppTextToString ppt = PP
  { ppCurrent = convert $ pptCurrent ppt
  , ppVisible = convert $ pptVisible ppt
  , ppHidden  = convert $ pptHidden ppt
  , ppHiddenNoWindows = convert $ pptHiddenNoWindows ppt
  , ppVisibleNoWindows = convert <$> pptVisibleNoWindows ppt
  , ppUrgent = convert $ pptUrgent ppt
  , ppSep = toString $ pptSep ppt
  , ppWsSep = toString $ pptWsSep ppt
  , ppTitle = convert $ pptTitle ppt
  , ppTitleSanitize = convert $ pptTitleSanitize ppt
  , ppLayout = convert $ pptLayout ppt
  , ppOrder = pptOrder ppt
  , ppSort = pptSort ppt
  , ppExtras = (fmap . fmap . fmap) toString $ pptExtras ppt
  , ppOutput = pptOutput ppt . toText
  }
  where convert f = toString . f . toText

ppStringToText :: PP -> PPText
ppStringToText pp = PPText
  { pptCurrent = convert $ ppCurrent pp
  , pptVisible = convert $ ppVisible pp
  , pptHidden  = convert $ ppHidden pp
  , pptHiddenNoWindows = convert $ ppHiddenNoWindows pp
  , pptVisibleNoWindows = convert <$> ppVisibleNoWindows pp
  , pptUrgent = convert $ ppUrgent pp
  , pptSep = toText $ ppSep pp
  , pptWsSep = toText $ ppWsSep pp
  , pptTitle = convert $ ppTitle pp
  , pptTitleSanitize = convert $ ppTitleSanitize pp
  , pptLayout = convert $ ppLayout pp
  , pptOrder = ppOrder pp
  , pptSort = ppSort pp
  , pptExtras = (fmap . fmap . fmap) toText $ ppExtras pp
  , pptOutput = ppOutput pp . toString
  }
  where convert f = toText . f . toString


instance Default PPText where
  def = ppStringToText def
#+end_src

The basic pretty-printer which the upcoming ones should override.
#+begin_src haskell
basicPP :: PPText
basicPP = def
  { pptSep = "  "
  , pptWsSep = " "
  , pptTitleSanitize = T.filter (`notElem` ['%','{','}'])
  , pptOrder = layoutFirstOrder
  , pptSort = getSortByIndex
  , pptExtras = []
  , pptOutput = const mempty
  }
  where
    layoutFirstOrder (workspaces : layout : title : extras) =
      [layout] ++ extras ++ [workspaces, title]
    layoutFirstOrder other = other
#+end_src

This is the one that finally gets applied.
#+begin_src haskell
chosenPP :: (PPText, PPText)
chosenPP = (onedarkFocusedPP, onedarkUnfocusedPP)
#+end_src

*** one-dark
#+begin_src haskell
onedarkFocusedPP :: PPText
onedarkFocusedPP = basicPP
  { pptCurrent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkGreen, Underline onedarkGreenDarker ] . pad
  , pptVisible = lemonbarFormat [ Foreground onedarkGreen, Background onedarkGrey, Underline onedarkGreen ] . pad
  , pptVisibleNoWindows = Just $ lemonbarFormat [ Foreground onedarkBlack, Background onedarkGrey, Underline onedarkGreen ] . pad
  , pptHidden = lemonbarFormat [ Foreground onedarkGreen, Underline onedarkGreen ] . pad
  , pptHiddenNoWindows = lemonbarFormat [ Foreground onedarkGrey ] . pad
  , pptUrgent = lemonbarFormat [ Foreground onedarkBlack, Background onedarkRed ] . pad
  , pptTitle = lemonbarFormat [ Foreground onedarkGrey ] . shorten 50
  , pptLayout = lemonbarFormat [ Foreground onedarkYellow ]
  }

onedarkUnfocusedPP :: PPText
onedarkUnfocusedPP = onedarkFocusedPP
  { pptCurrent = Unsafe.fromJust $ pptVisibleNoWindows onedarkFocusedPP
  , pptVisible = pptHiddenNoWindows onedarkFocusedPP
  , pptVisibleNoWindows = Just $ pptHiddenNoWindows onedarkFocusedPP
  , pptHidden = pptHiddenNoWindows onedarkFocusedPP
  }
#+end_src

** Dynamic bar highlighting and management
=DynamicBars= asks for a bar startup function of the type =ScreenId -> IO Handle=, where =ScreenId= is simply a newtype for =Int=.
On the other hand, Polybar requires an xrandr monitor name to know which screen to use. So first we need a mapping between the two.
I simply use =xrandr= to query which monitors are active and hope to dear god that they are in the same order as the =ScreenId='s.
So far I have not been let down.
#+begin_src haskell
monitorIds :: IO [(ScreenId, Text)]
monitorIds = do
  output <- toText <$> outputOf "xrandr --listactivemonitors 2>/dev/null | awk '{print $1 $4}'"
  return $ mapMaybe parseMonitor . drop 1 $ lines output
  where
    parseMonitor :: Text -> Maybe (ScreenId, Text)
    parseMonitor text = do
      let (idText, monitorText) = T.breakOn ":" text
      monitor <- T.stripPrefix ":" monitorText
      id <- readMaybe . toString $ idText
      return (S id, monitor)
#+end_src

We want to use =spawnPipe= to start polybar and pass input to its stdin, but unfortunately polybar doesn't read from there.
So we need to use an intermediary to pass it into polybar through a named pipe. We /could/ do this from xmonad itself, but then
we have to maintain consistency between xmonad and polybar about the name of the pipe. That, and using named pipes in haskell
turns out to have a lot of gotchas. We do this through a shell script =polybar-start-monitor.sh=

The relevant polybar module just reads a the passed environment variable =STDINFIFO=
#+begin_src conf :tangle no
[module/stdin]
type = custom/script
tail = true
exec = cat $STDINFIFO
#+end_src

And finally the startup and cleanup functions for the bar.
#+begin_src haskell
polybarStartup :: ScreenId -> IO Handle
polybarStartup screenId = do
  monitors <- monitorIds
  case P.lookup screenId monitors of
    Just monitor -> spawnPipe . toString $ format1 "bin/polybar-start-monitor.sh {}" monitor
    Nothing -> error $ format "No monitor found for {} in {}" (P.show screenId, P.show monitors)

polybarCleanup :: IO ()
polybarCleanup = do
  (CPid pid) <- getProcessID
  spawn $ printf "pkill --parent %d bin/polybar-start-monitor.sh" pid
#+end_src

And then plumb everything together with =DynamicBars= and =ManageDocks= (to actually make space for the bar).
#+begin_src haskell
polybarEnable :: LayoutClass l Window
              => PP
              -> PP
              -> XConfig l
              -> XConfig (ModifiedLayout AvoidStruts l)
polybarEnable focusedPP unfocusedPP config@XConfig{..}  = docks $ config
  { startupHook     = startupHook      <+> dynStatusBarStartup polybarStartup polybarCleanup
  , handleEventHook = handleEventHook  <+> dynStatusBarEventHook polybarStartup polybarCleanup
  , logHook         = logHook          <+> multiPP focusedPP unfocusedPP
  , layoutHook      = avoidStruts $ layoutHook
  }
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , handleExtraArgs = handleTestConditions
  , keys            = myKeymap
  , mouseBindings   = myMouseBindings
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

handleTestConditions :: [String] -> XConfig Layout -> IO (XConfig Layout)
handleTestConditions args config = case args of
  []         -> return config
  ["--test"] -> return config { modMask = testModMask }
  otherwise  -> putStrLn ("Unexpected arguments encountered: " ++ show args) >> return config
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys

myKeys :: [(String, X ())]
myKeys = concat
  [ xmonadControlKeys
  , applicationKeys
  , infoKeys
  ]
#+end_src

Some quick helper functions
#+begin_src haskell
spawnKeymap :: Text -> [(Text, Text, String)] -> (String, X ())
spawnKeymap key items = (toString key, whichkeySubmap def myConfig $ mapThd3 spawn <$> items)
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

*** Opening applications
Keys for well, opening applications. Most things can be accessed through the smart launcher =albert= through ~M-o~, but it's faster to have some shortcuts for commonly used apps.
#+name: opening-apps
#+begin_src haskell
applicationKeys = return $ spawnKeymap "M-u" apps
  where
    apps = [ ("t"  , "Terminal"    , terminal myConfig)
           , ("e"  , "Emacs Client", "emacsclient -c")
           , ("S-e", "Emacs"       , "emacs")
           , ("f"  , "Firefox"     , "firefox")
           , ("r"  , "Ranger"      , "$TERMINAL ranger")
           , ("w"  , "WhatsApp"    , "whatsapp.sh")
           ]
#+end_src

*** Info keys
Keys for referring to information quickly - latex symbols, nerdfont icons etc.
#+begin_src haskell
infoKeys = return $ spawnKeymap "M-i" info
  where
    info = [ ("n"  , "Nerdfont reference"      , "nerdfont-dmenu.sh")
           , ("l"  , "LaTeX symbol reference"  , "xdg-open http://detexify.kirelabs.org/classify.html")
           , ("x m", "xmonad reference"        , "xdg-open https://hackage.haskell.org/package/xmonad")
           , ("x c", "xmonad-contrib reference", "xdg-open https://hackage.haskell.org/package/xmonad-contrib")
           ]
#+end_src

** Mouse bindings
Let's keep this empty for now. The default behaviour of making windows floating when dragged around is really irritating.
#+begin_src haskell
myMouseBindings :: XConfig Layout -> Map (ButtonMask, Button) (Window -> X ())
myMouseBindings config = fromList []
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
The default cursor is also... not the best - change it to something more standard.
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
    setDefaultCursor xC_left_ptr
#+end_src

* Running
** Restarting
=restartConfig= copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
Using =SomeException= catches all exceptions
#+begin_src haskell
buildConfig :: X Bool
buildConfig =
  io $ (try (system "bin/build") :: IO (Either SomeException ExitCode)) >>= \case
    Right ExitSuccess -> return True
    Right (ExitFailure failCode) -> displayTextTill errTime (format "Build failed with code: {}" (Only failCode)) >> return False
    Left exception -> displayTextTill errTime (format "Build failed with exception: {}" (Only $ displayException exception)) >> return False
  where
    errTime = 5

restartConfig :: Bool -> X ()
restartConfig resume = do
  uninstallSignalHandlers
  whenX buildConfig $ do
    broadcastMessage ReleaseResources
    io . flush =<< asks display
    when resume writeStateToFile
    origArgs <- io getArgs
    catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Logging
There's two ways to view xmonad logs. Either you set =exec <xmonad executable>= in your =.xinitrc= and redirect the logs of your X session with =startx &> <logfile>=.
The other, cleaner way, is to tell hardcode the path in =xmonad= itself. This way you're free to start your session however and not capture /all/ the logs.

This [[https://www.reddit.com/r/xmonad/comments/cr0ry3/viewing_stderr_from_stack_config/exkkmie/][code]] accomplishes this, courtesy of [[https://www.reddit.com/user/simonfxr/][u/simonfixr]].
#+begin_src haskell
redirectStdHandles :: FilePath -> IO ()
redirectStdHandles directory = do
  createDirectoryIfMissing True directory
  hClose stdout
  hClose stderr
  stdout' <- openFile (directory </> "xmonad-stdout.log") WriteMode
  stderr' <- openFile (directory </> "xmonad-stderr.log") WriteMode
  hDuplicateTo stdout' stdout
  hDuplicateTo stderr' stderr

redirectLogs :: FilePath -> XConfig l -> XConfig l
redirectLogs directory conf@XConfig{startupHook} =
  conf { startupHook = io (redirectStdHandles directory) >> startupHook }
#+end_src

** Main
The default =xmonad= executable handles a lot of things in its =main= -- replacing, resuming, building etc.
This makes it a lot more complicated to think about as we might reenter =main= at any point while maintaining state in the filesystem.
To keep things simple, in this configuration, building is handled by the =build= script which can be executed by hand or during recompilation through the executable.
#+begin_src haskell
main :: IO ()
main = do
  args <- getArgs
  conf' @ XConfig { layoutHook = Layout l }
                  <- handleExtraArgs myConfig args myConfig{ layoutHook = Layout (layoutHook myConfig) }
  launch
    $ uncurry polybarEnable (bimapBoth ppTextToString chosenPP)
    $ redirectLogs "/tmp"
    $ conf' { layoutHook = l }
#+end_src
