#+TITLE: disconsis' literate XMonad configuration
#+AUTHOR: Ketan Kanishka (=disconsis=)
#+PROPERTY: header-args :tangle "Main.hs"

* Imports
Libraries for system IO actions
#+begin_src haskell
import System.Process (system)
import System.Posix.Process (executeFile)
import System.Environment (getArgs)
import System.Exit (exitSuccess)
#+end_src

Some general libraries
#+begin_src haskell
import Control.Monad
#+end_src

Base =XMonad= import(s)
#+begin_src haskell
import XMonad
#+end_src

=EZConfig= for emacs-style keybinding descriptions
#+begin_src haskell
import XMonad.Util.EZConfig (mkKeymap, checkKeymap)
#+end_src

* Config
#+begin_src haskell
myConfig = def
  { terminal        = myTerminal
  , modMask         = myModMask
  , handleExtraArgs = handleTestConditions
  , keys            = myKeymap
  , startupHook     = myStartupHook
  }
#+end_src

** Terminal
Preferred terminal is kitty (for the ligatures) with tmux (for splitting).
#+begin_src haskell
myTerminal = "kitty tmux -2"
#+end_src

** Mod key (default and test)
Selecting the mod key is a bit trickier than expected to be able to test the config in an inferior X session.
The key I want to use is =Alt= (=mod1Mask=), but if I'm also using this config while testing a modified version of it,
then those keypresses are intercepted by XMonad and not passed to the inferior X session. The simplest way to get
around this is to switch to =Super= (=mod4Mask=) when an additional =--test= argument is passed.
#+begin_src haskell
myModMask   = mod1Mask
testModMask = mod4Mask

handleTestConditions :: [String] -> XConfig Layout -> IO (XConfig Layout)
handleTestConditions args config = case args of
  []         -> return config
  ["--test"] -> return config { modMask = testModMask }
  otherwise  -> putStrLn ("Unexpected arguments encountered: " ++ show args) >> return config
#+end_src

** Keys
#+begin_src haskell
myKeymap = flip mkKeymap myKeys
myKeys = concat
  [ xmonadControlKeys
  ]
#+end_src

*** Controlling XMonad
Keys for restarting, recompiling, quitting (etc?) XMonad
#+begin_src haskell
xmonadControlKeys =
  [ ("M-`", restartConfig True)
  , ("M-S-C-`", io exitSuccess)
  ]
#+end_src

** Startup actions
First thing we should do is check our keybindings for errors and duplicates.
The =return ()= is neccessary to add some lazinesss to prevent the infinite loop of =myConfig -> myStartupHook -> myConfig -> ...= (see the docs for [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:checkKeymap][checkKeymap]] for more details)
#+begin_src haskell
  myStartupHook :: X ()
  myStartupHook = do
    return () >> checkKeymap myConfig myKeys
#+end_src

* Running
** Restarting
Copied almost verbatim from =XMonad.Operations.restart=
=uninstallSignalHandlers= is needed to get =stack build= to work correctly, since it otherwise
ignores the =SIGCHLD= signals it needs to function correctly
#+begin_src haskell
restartConfig :: Bool -> X ()
restartConfig resume = do
  uninstallSignalHandlers
  io $ system "bin/build"
  broadcastMessage ReleaseResources
  io . flush =<< asks display
  when resume writeStateToFile
  origArgs <- io getArgs
  catchIO (executeFile "bin/launch" True origArgs Nothing)
#+end_src

** Main
The default =xmonad= executable handles a lot of things in its =main= -- replacing, resuming, building etc.
This makes it a lot more complicated to think about as we might reenter =main= at any point while maintaining state in the filesystem.
To keep things simple, in this configuration, building is handled by the =build= script which can be executed by hand or during recompilation through the executable.
#+begin_src haskell
main :: IO ()
main = do
  args <- getArgs
  conf' @ XConfig { layoutHook = Layout l }
                  <- handleExtraArgs myConfig args myConfig{ layoutHook = Layout (layoutHook myConfig) }
  launch $ conf' { layoutHook = l }
#+end_src
